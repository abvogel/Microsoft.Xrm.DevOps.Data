<#@ template language="C#" hostspecific="true" #>
<#@ parameter type="CrmCodeGenerator.VSPackage.Model.Context" name="Context"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="CrmCodeGenerator.VSPackage.Model" #>
<#@ assembly name="EnvDTE"#>
<#@ assembly name="System.Data.Linq" #>
<#@ assembly name="System.Xml"#>
<#@ assembly name="System.Xml.Linq"#>
<#@ import namespace="System"#>
<#@ import namespace="System.CodeDom"#>
<#@ import namespace="System.CodeDom.Compiler"#>
<#@ import namespace="System.Data.Linq"#>
<#@ import namespace="System.Data.Linq.Mapping"#>
<#@ import namespace="System.IO"#>
<#@ import namespace="System.Reflection"#>
<#@ import namespace="System.Text"#>
<#@ import namespace="System.Xml.Linq"#>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating"#>
<#@ import namespace="System.Text.RegularExpressions"#>
<#@ import namespace="System.Globalization"#>
<# // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Template version 6.13.1 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< #>
<# // >>>>>>>>>> MINIMUM COMPATIBLE VERSION to successfully generate the schema using this template is 6.10.1. <<<<<<<<<< #>
//         Project / File: <#= Context.Namespace #> / <#= Context.FileName #>.cs
// File generated by: CRM Code Generator - Eric Labashosky, Ahmed el-Sawalhy

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;
using System.Reflection;
using System.ServiceModel;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Client;
using Microsoft.Xrm.Sdk.Messages;
using Microsoft.Xrm.Sdk.Query;

<# if (Context.FileName == "CrmSchema") { #>[assembly: ProxyTypesAssemblyAttribute()]<#}#>

namespace <#= Context.Namespace #><# if (Context.FileName != "CrmSchema") { #>.<#= Context.FileName #><#}#>

{
	#region XrmServiceContext

	/// <summary>
	/// Represents a source of entities bound to a CRM service. It tracks and manages changes made to the retrieved entities.
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode()]
	public partial class XrmServiceContext : OrganizationServiceContext
	{
		/// <summary>
		/// Constructor.
		/// </summary>
		public XrmServiceContext(IOrganizationService service) : 
				base(service)
		{
		}

<# foreach (var entityQ in Context.Entities) {
			var crmEntityName =  Context.EntityDataFilterArray.EntityFilters.First(filter => filter.IsDefault)
				.EntityFilterList.First(filter => filter.LogicalName == entityQ.LogicalName).EntityRename
				?? (Context.UseDisplayNames ? entityQ.FriendlyName : entityQ.HybridName);
#>
		/// <summary>
		/// Gets a binding to the set of all <see cref="<#= crmEntityName #>"/> entities.
		/// </summary>
		public System.Linq.IQueryable<<#= crmEntityName #>> <#= crmEntityName #>Set
		{
			get
			{
				return this.CreateQuery<<#= crmEntityName #>>();
			}
		}
<#}#>
	}

	#endregion

	#region Extensions

    public class ValidationError
    {
        public Guid? RecordId;
        public string AttributeName;

        public ValidationType ErrorType;
        public IDictionary<int, string> ErrorMessage;

        public string StringValue;
        public int? StringMaxLength;

        public decimal? NumericValue;
        public decimal? NumericRangeMin;
        public decimal? NumericRangeMax;
    }

	public class ValidationLocalisation
	{
		public ValidationType ErrorType;
		/// <summary>
		/// A dictionary of language code as key and message format as value
		/// </summary>
		public IDictionary<int, string> Localisation;
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public static class CrmGeneratorExtensions
	{
		/// <summary>
		/// Retrieves the label of the 'OptionSetValue' using the corresponding enum member constant
		/// and the language code given.
		/// </summary>
		/// <param name="enumMember">The early-bound enum member constant; e.g.: 'Account.Enums.IndustryCode.Accounting'</param>
		/// <param name="languageCode">The language code from CRM</param>
		/// <returns>The label corresponding to the enum constant and the language code.</returns>
		public static string GetLabel(this Enum enumMember, int languageCode = 1033)
		{
			var enumType = enumMember.GetType();
			var enumParentType = enumType.DeclaringType;

			if (enumParentType == null)
			{
				return "NO_LABEL";
			}

			var enumsType = enumParentType.GetNestedType("Enums");

			if (enumsType == null)
			{
				return "NO_LABEL";
			}

			var labelsType = enumsType.GetNestedType("Labels");

			if (labelsType == null)
			{
				return "NO_LABEL";
			}

			var labelType = labelsType.GetNestedType(enumType.Name.Substring(0, enumType.Name.LastIndexOf("Enum")));

			if (labelType == null)
			{
				return "NO_LABEL";
			}

			var field = labelType.GetField(enumMember + "_" + languageCode);

			return field == null ? "NO_LABEL" : field.GetValue(labelType).ToString();
		}

		/// <summary>
		/// Converts an enum constant to an OptionSetValue object..
		/// </summary>
		/// <param name="enumMember">The early-bound enum member constant; e.g.: 'Account.IndustryCode.Accounting'</param>
		/// <returns>The OptionSetValue object.</returns>
		public static OptionSetValue ToOptionSetValue(this Enum enumMember)
		{
			return new OptionSetValue(int.Parse(enumMember.ToString("d")));
		}

		/// <summary>
		///     Validates that all field values in this record adhere to their contraints specified in CRM.<br />
		///     Validation checks: required, numeric value range, and string length.<br />
		/// </summary>
		/// <param name="validationTypes">An array of validations to run. Default is all.</param>
		/// <returns>A single message containing all validation errors.</returns>
		public static string GetValidationErrorsMessage(this Entity entityRecord, ValidationType[] validationTypes)
		{
			return GetValidationErrorsMessage(entityRecord,
				validationLocationsDefaults.Where(local => validationTypes.Contains(local.ErrorType)).ToArray());
		}

		/// <summary>
		///     Validates that all field values in this record adhere to their contraints specified in CRM.<br />
		///     Validation checks: required, numeric value range, and string length.<br />
		/// </summary>
		/// <param name="validationLocalisation">
		///     [OPTIONAL] An array containing validation types with the message format to use for the validation error.<br />
		///     For validation type "InRange", the message format takes three params for min, max, and actual value respectively;
		///         e.g.: "Value must be between {0} and {1}. Actual value was {2}.".<br />
		///     For validation type "MaxLength", the message format takes two params;
		///		    e.g.: "Value length must be less than {0}. Actual value was {1}."<br />
		///     Only include ONE localisation language.<br />
		///     Default is a check on all validation types.
		/// </param>
		/// <returns>A single message containing all validation errors.</returns>
		public static string GetValidationErrorsMessage(this Entity entityRecord, ValidationLocalisation[] validationLocalisation = null)
		{
			if (validationLocalisation != null
				&& validationLocalisation.Any(local => local.Localisation.Count > 1))
			{
				throw new ArgumentOutOfRangeException("validationLocalisation",
					"There should only be one validation localisation language for this method.");
			}

			var validationErrorMessages = GetValidationErrorMessages(entityRecord, validationLocalisation);

			if (validationErrorMessages.Any())
			{
				return validationErrorMessages.Aggregate(
					(message1, message2) => message1 + "\r\n-----------------------\r\n" + message2);
			}

			return null;
		}

		private static readonly ValidationLocalisation[] validationLocationsDefaults =
		{
			new ValidationLocalisation
			{
				ErrorType = ValidationType.Required,
				Localisation = new Dictionary<int, string>
				               {
					               {1033, "Value cannot be null."}
				               }
			},
			new ValidationLocalisation
			{
				ErrorType = ValidationType.InRange,
				Localisation = new Dictionary<int, string>
				               {
					               {1033, @"Attribute value must be between ""{0}"" and ""{1}"", inclusive. Actual value was ""{2}""."}
				               }
			},
			new ValidationLocalisation
			{
				ErrorType = ValidationType.MaxLength,
				Localisation = new Dictionary<int, string>
				               {
					               {1033, @"Attribute length must be less than ""{0}"". Actual attribute value was ""{1}""."}
				               }
			}
		};

		/// <summary>
		///     Validates that all field values in this record adhere to their contraints specified in CRM.<br />
		///     Validation checks: required, numeric value range, and string length.<br />
		/// </summary>
		/// <param name="validationTypes">An array of validations to run.</param>
		/// <returns>A list of messages indicating validation errors.</returns>
		public static List<string> GetValidationErrorMessages(this Entity entityRecord, ValidationType[] validationTypes)
		{
			return GetValidationErrorMessages(entityRecord,
				validationLocationsDefaults.Where(local => validationTypes.Contains(local.ErrorType)).ToArray());
		}

		/// <summary>
		///     Validates that all field values in this record adhere to their contraints specified in CRM.<br />
		///     Validation checks: required, numeric value range, and string length.<br />
		/// </summary>
		/// <param name="validationLocalisation">
		///     [OPTIONAL] An array containing validation types with the message format to use for the validation error.<br />
		///     For validation type "InRange", the message format takes three params for min, max, and actual value respectively;
		///         e.g.: "Value must be between {0} and {1}. Actual value was {2}.".<br />
		///     For validation type "MaxLength", the message format takes two params;
		///		    e.g.: "Value length must be less than {0}. Actual value was {1}."<br />
		///     Only include ONE localisation language.<br />
		///     Default is a check on all validation types.
		/// </param>
		/// <returns>A list of messages indicating validation errors.</returns>
		public static List<string> GetValidationErrorMessages(this Entity entityRecord, ValidationLocalisation[] validationLocalisation = null)
		{
			if (validationLocalisation != null
			    && validationLocalisation.Any(local => local.Localisation.Count > 1))
			{
				throw new ArgumentOutOfRangeException("validationLocalisation",
					"There should only be one validation localisation language for this method.");
			}

			var validationErrors = GetValidationErrors(entityRecord, validationLocalisation);

			if (validationErrors.Any())
			{
				var messages = validationErrors.Select(error => error.ErrorMessage.Values.First()).ToList();
				var id = ((dynamic)entityRecord).Id;
				messages.Insert(0, string.Format("Record of type \"{0}\"" + (id != null ? " and ID \"{1}\"" : "")
													+ " has invalid values.", entityRecord.GetType().Name, id));
				return messages;
			}

			return null;
		}

		/// <summary>
		///     Validates that all field values in this record adhere to their contraints specified in CRM.<br />
		///     Validation checks: required, numeric value range, and string length.<br />
		/// </summary>
		/// <param name="validationTypes">An array of validations to run.</param>
		/// <returns>A list of validation errors in the form of <see cref="ValidationError"/>.</returns>
		public static List<ValidationError> GetValidationErrors(this Entity entityRecord, ValidationType[] validationTypes)
		{
			return GetValidationErrors(entityRecord,
				validationLocationsDefaults.Where(local => validationTypes.Contains(local.ErrorType)).ToArray());
		}

		///  <summary>
		///      Validates that all field values in this record adhere to their contraints specified in CRM.<br />
		///      Validation checks: required, numeric value range, and string length.<br />
		///  </summary>
		///  <param name="validationLocalisation">
		///      [OPTIONAL] An array containing validation types with the message format to use for the validation error.<br />
		///      For validation type "InRange", the message format takes three params for min, max, and actual value respectively;
		///          e.g.: "Value must be between {0} and {1}. Actual value was {2}.".<br />
		///      For validation type "MaxLength", the message format takes two params;
		/// 		    e.g.: "Value length must be less than {0}. Actual value was {1}."<br />
		///      Default is a check on all validation types.
		///  </param>
		/// <returns>A list of validation errors in the form of <see cref="ValidationError"/>.</returns>
		public static List<ValidationError> GetValidationErrors(this Entity entityRecord, ValidationLocalisation[] validationLocalisation = null)
		{
			var id = ((dynamic) entityRecord).Id;
			var fields = entityRecord.GetType().GetProperties();
			var exceptions = new List<ValidationError>();

			validationLocalisation = validationLocalisation ?? validationLocationsDefaults;

			var localisation = validationLocalisation.FirstOrDefault(local => local.ErrorType == ValidationType.Required);

			if (localisation != null)
			{
				exceptions.AddRange(from fieldQ in fields
				                    where Attribute.IsDefined(fieldQ, typeof (RequiredAttribute))
				                          && fieldQ.GetValue(entityRecord) == null
				                    select new ValidationError
				                           {
					                           RecordId = id,
					                           AttributeName = fieldQ.Name,
					                           ErrorMessage =
						                           localisation.Localisation.ToDictionary(local => local.Key, local => local.Value),
					                           ErrorType = ValidationType.Required
				                           });
			}

			localisation = validationLocalisation.FirstOrDefault(local => local.ErrorType == ValidationType.InRange);

			if (localisation != null)
			{
				foreach (var field in fields.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof (InRangeAttribute)) && fieldQ.GetValue(entityRecord) != null))
				{
					var fieldValue = field.GetValue(entityRecord);
					Type type = field.GetCustomAttribute<InRangeAttribute>().Type;

					var method = type.GetMethods().FirstOrDefault(methodQ => methodQ.GetParameters().Length == 1 && methodQ.Name == "Parse");

					var min = (IComparable) method.Invoke(null, new object[] {field.GetCustomAttribute<InRangeAttribute>().Min});
					var max = (IComparable) method.Invoke(null, new object[] {field.GetCustomAttribute<InRangeAttribute>().Max});

					if (fieldValue != null && (min.CompareTo(fieldValue) == 1 || max.CompareTo(fieldValue) == -1))
					{
						exceptions.Add(new ValidationError
						               {
							               RecordId = id,
							               AttributeName = field.Name,
							               ErrorMessage = localisation.Localisation.ToDictionary(local => local.Key,
									               local => string.Format(local.Value, min, max, fieldValue)),
							               ErrorType = ValidationType.InRange,
							               NumericValue = decimal.Parse(fieldValue.ToString()),
							               NumericRangeMin = decimal.Parse(min.ToString()),
							               NumericRangeMax = decimal.Parse(max.ToString())
						               });
					}
				}
			}


			localisation = validationLocalisation.FirstOrDefault(local => local.ErrorType == ValidationType.MaxLength);

			if (localisation != null)
			{
				exceptions.AddRange(from fieldQ in fields.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof (MaxLengthAttribute)))
				                    let fieldValue = fieldQ.GetValue(entityRecord) as string
				                    let maxLength = fieldQ.GetCustomAttribute<MaxLengthAttribute>().Max
				                    where fieldValue != null && fieldValue.Length > maxLength
				                    select new ValidationError
				                           {
					                           RecordId = id,
					                           AttributeName = fieldQ.Name,
					                           ErrorMessage = localisation.Localisation.ToDictionary(local => local.Key,
							                           local => string.Format(local.Value, maxLength, fieldValue)),
					                           ErrorType = ValidationType.MaxLength,
					                           StringValue = fieldValue,
					                           StringMaxLength = maxLength
				                           });
			}

			return exceptions;
		}

		public static TEntity ConvertTo<TEntity>(this Entity crmRecord) where TEntity : EntityContract
		{
			// create entity object
			var record = Activator.CreateInstance<TEntity>();

			var entityType = typeof(TEntity);
			var entityLogicalName = entityType.GetCustomAttribute<CrmEntityMappingAttribute>().LogicalName;


			// if logical names don't match
			if (entityLogicalName != crmRecord.LogicalName)
			{
				throw new Exception(string.Format("CRM entity '{0}' doesn't map to entity '{1}'.",
					crmRecord.GetType().Name, entityType.Name));
			}

			// go over all fields in the contract entity that has the mapping attribute
			foreach (var field in entityType.GetFields()
				.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof(CrmFieldMappingAttribute))
								 && !Attribute.IsDefined(fieldQ, typeof(CrmRelationMappingAttribute))))
			{
				// get the value of the mapping attribute
				var mapping = field.GetCustomAttribute<CrmFieldMappingAttribute>();
				SetValueInRecord(record, field, crmRecord, mapping);
			}

			// go over all relations in the contract entity that has the mapping attribute
			foreach (var relation in typeof(TEntity).GetFields()
				.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof(CrmRelationMappingAttribute))
						&& !Attribute.IsDefined(fieldQ, typeof(CrmFieldMappingAttribute))))
			{
				// get the value of the mapping attribute
				var mapping = relation.GetCustomAttribute<CrmRelationMappingAttribute>();
				SetRelationInRecord(record, relation, crmRecord, mapping);
			}

			return record;
		}

		private static void SetValueInRecord<TEntity>(TEntity entity, FieldInfo field, Entity crmRecord,
			CrmFieldMappingAttribute mapping)
			where TEntity : EntityContract
		{
			// if key not found, then the CRM record doesn't have that value set
			if (!crmRecord.Attributes.Contains(mapping.LogicalName))
			{
				return;
			}

			var value = crmRecord[mapping.LogicalName];

			// convert types
			if (value is OptionSetValue)
			{
				// can't set enum value with int using reflection!
				field.SetValue(entity, Enum.ToObject(Nullable.GetUnderlyingType(field.FieldType),
					((OptionSetValue)value).Value));

				var labelsProperty = typeof(TEntity).GetProperties().FirstOrDefault(propQ => propQ.Name == field.Name + "Labels");

                if (labelsProperty != null)
                {
                    // get the label value from the CRM record
                    var matchingProperty = crmRecord.GetType().GetProperties().FirstOrDefault(propQ => propQ.Name == field.Name + "Labels");

                    // if it has a value, set it in contract
                    if (matchingProperty != null)
                    {
                        labelsProperty.SetValue(entity, matchingProperty.GetValue(crmRecord));
                    }
                }
			}
			else if (value is Money)
			{
				field.SetValue(entity, ((Money)value).Value);
			}
			else if (value is EntityReference && field.FieldType != typeof(EntityReference))
			{
				var entityRef = (EntityReference) value;

				field.SetValue(entity, entityRef.Id);

				var nameField = typeof(TEntity).GetFields().FirstOrDefault(fieldQ => fieldQ.Name == field.Name + "Name");

				if (nameField != null && entityRef.Name != null)
				{
					nameField.SetValue(entity, entityRef.Name);
				}

				var labelsProperty = typeof(TEntity).GetProperties().FirstOrDefault(propQ => propQ.Name == field.Name + "Labels");

                if (labelsProperty != null)
                {
                    // get the label value from the CRM record
                    var matchingProperty = crmRecord.GetType().GetProperties().FirstOrDefault(propQ => Attribute.IsDefined(propQ, typeof(LabelAttribute))
                        && propQ.GetCustomAttribute<LabelAttribute>().FieldLogicalName == labelsProperty.GetCustomAttribute<LabelAttribute>().FieldLogicalName);

                    // if it has a value, set it in contract
                    if (matchingProperty != null)
                    {
                        labelsProperty.SetValue(entity, matchingProperty.GetValue(crmRecord));
                    }
                }
			}
			else
			{
				field.SetValue(entity, value);
			}
		}

		private static void SetRelationInRecord<TEntity>(TEntity record, FieldInfo field, Entity crmRecord,
			CrmRelationMappingAttribute mapping)
			where TEntity : EntityContract
		{
			var crmRelations = crmRecord.RelatedEntities
				.Where(relationQ => relationQ.Key.SchemaName == mapping.SchemaName
									&& relationQ.Key.PrimaryEntityRole == mapping.Role);

			// if relation not found in CRM record, exit
			if (!crmRelations.Any())
			{
				return;
			}

			var crmRelatedRecords = crmRelations.First().Value.Entities;

			// if there are not related entities in the CRM relation, exit
			if (!crmRelatedRecords.Any())
			{
				return;
			}

			var fieldType = field.FieldType;

			object convertedValue = null;

			// x-N relation
			if (typeof(Array).IsAssignableFrom(fieldType))
			{
				// get the contract type for the relation
				var elementType = fieldType.GetElementType();

				// create an array for the related entities of the appropriate type
				var relatedRecords = Array.CreateInstance(elementType, crmRelatedRecords.Count);

				// create the method reference that will be used to convert the related entities to the CRM entities
				var method = MethodBase.GetCurrentMethod().DeclaringType
					.GetMethod("ConvertTo").MakeGenericMethod(elementType);

				// convert all entities to contract entities
				var objectRelatedRecords = (from object relatedRecord in crmRelatedRecords
											select method.Invoke(relatedRecord, new[] { relatedRecord })).ToArray();

				// copy the object entities to the array of the specific type
				Array.Copy(objectRelatedRecords, relatedRecords, relatedRecords.Length);
				convertedValue = relatedRecords;
			}
			else if (typeof(EntityContract).IsAssignableFrom(fieldType))
			{
				// N-1 relation
				var relatedRecord = crmRelatedRecords.FirstOrDefault();

				if (relatedRecord != null)
				{
					// go over all fields in the contract entity that has the mapping attribute
					foreach (var fieldT in typeof(TEntity).GetFields()
						.Where(fieldQ => fieldQ.Name.Contains(field.Name)
						&& Attribute.IsDefined(fieldQ, typeof(CrmFieldMappingAttribute))))
					{
						// get the value of the mapping attribute
						var mappingT = fieldT.GetCustomAttribute<CrmFieldMappingAttribute>();
						SetValueInRecord(record, fieldT, relatedRecord, mappingT);
					}
					// create the method reference that will be used to convert the related entities to the CRM entities
					var method = MethodBase.GetCurrentMethod().DeclaringType
						.GetMethod("ConvertTo").MakeGenericMethod(fieldType);

					convertedValue = method.Invoke(relatedRecord, new object[] { relatedRecord });
				}
			}

			// set the related entities value in the entity
			field.SetValue(record, convertedValue);
		}

		/// <summary>
		/// Returns an array of logical names whose property is marked for WCF contract.
		/// </summary>
		/// <param name="entity"></param>
		/// <returns>An array of logical names.</returns>
		public static string[] GetDataMemberAttributes(this Entity entity)
		{
			return entity.GetType().GetProperties()
				.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof(DataMemberAttribute)) && Attribute.IsDefined(fieldQ, typeof(AttributeLogicalNameAttribute)))
				.Select(field => field.GetCustomAttribute<AttributeLogicalNameAttribute>().LogicalName).ToArray();
		}

		/// <summary>
		/// Returns an array of logical names of the properties.
		/// </summary>
		/// <param name="entity"></param>
		/// <returns>An array of logical names.</returns>
		public static string[] GetAttributeNames(this Entity entity)
		{
			return entity.GetType().GetProperties()
				.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof(AttributeLogicalNameAttribute)) && !Attribute.IsDefined(fieldQ, typeof(RelationshipSchemaNameAttribute)))
				.Select(field => field.GetCustomAttribute<AttributeLogicalNameAttribute>().LogicalName).ToArray();
		}

		/// <summary>
		/// Loads the values of data member properties from CRM.
		/// </summary>
		/// <param name="entity"></param>
		/// <param name="service">CRM organisation service.</param>
		public static void LoadDataMemberAttributes(this Entity entity, IOrganizationService service)
		{
			LoadAttributeValues(entity, service, entity.GetDataMemberAttributes());
		}

		/// <summary>
		/// Loads the values of all properties from CRM.
		/// </summary>
		/// <param name="entity"></param>
		/// <param name="service">CRM organisation service.</param>
		/// <param name="attributes"></param>
		public static void LoadAttributeValues(this Entity entity, IOrganizationService service, params string[] attributes)
		{
			try
			{
				entity.Id = entity.Id;
			}
			catch
			{
				throw new Exception("Entity is ready only. Set 'MergeOption' to 'NoTracking' in the context used for fetching this entity.");
			}

			var isLoadAll = attributes == null || attributes.Length <= 0;

			if (isLoadAll)
			{
				entity.Attributes.Clear();
			}

			foreach (var attribute in service.Retrieve(entity.LogicalName, entity.Id, new ColumnSet(isLoadAll ? entity.GetAttributeNames() : attributes)).Attributes)
			{
				entity[attribute.Key] = attribute.Value;
			}
		}
	}

	#endregion

	#region Helpers

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public abstract class GeneratedEntityBase : Entity, INotifyPropertyChanging, INotifyPropertyChanged
	{
		public GeneratedEntityBase()
		{}

		public GeneratedEntityBase(string logicalName) : base(logicalName)
		{}

		[DataMember]
		private List<string> NullValuedAttributes { get; set; }
		protected Microsoft.Xrm.Sdk.AttributeCollection backupAttributeCollection;
		protected FormattedValueCollection backupFormattedCollection;
		protected RelatedEntityCollection backupRelatedEntityCollection;
		internal IList<QueryAction> DeferredQueriesList = new List<QueryAction>();
		protected IDictionary<string, object[]> relationProperties;
		protected virtual IDictionary<string, object[]> RelationProperties { get { return new Dictionary<string, object[]>(); } }

		#region Serialisation events

		[OnSerializing]
		private void SerializingInitializer(StreamingContext ctx)
		{
			backupAttributeCollection = new Microsoft.Xrm.Sdk.AttributeCollection();
			backupAttributeCollection.AddRange(Attributes);
			Attributes.Clear();

			backupFormattedCollection = new FormattedValueCollection();
			backupFormattedCollection.AddRange(FormattedValues);
			FormattedValues.Clear();

			backupRelatedEntityCollection = new RelatedEntityCollection();
			backupRelatedEntityCollection.AddRange(RelatedEntities);
			RelatedEntities.Clear();
		}

		[OnSerialized]
		private void SerializedInitializer(StreamingContext ctx)
		{
			Attributes.Clear();
			Attributes.AddRange(backupAttributeCollection);
			backupAttributeCollection = null;

			FormattedValues.Clear();
			FormattedValues.AddRange(backupFormattedCollection);
			backupFormattedCollection = null;

			RelatedEntities.Clear();
			RelatedEntities.AddRange(backupRelatedEntityCollection);
			backupRelatedEntityCollection = null;
		}

		[OnDeserialized]
		private void DeserializedInitializer(StreamingContext ctx)
		{
			LogicalName = (string)GetType().GetField("EntityLogicalName").GetRawConstantValue();
			Attributes.Where(attribute => attribute.Value == null).ToList().ForEach(attribute => Attributes.Remove(attribute.Key));
			if (NullValuedAttributes != null && NullValuedAttributes.Count > 0)
			{
				NullValuedAttributes.ForEach(attribute =>
				{
					var property = GetType().GetProperty(attribute);
					if (property == null)
					{
						throw new Exception("Couldn't find the property '" + attribute + "' in entity.");
					}
					property.SetValue(this, null);
				});
			}
		}

		#endregion

		public XrmServiceContext ServiceContext { get; set; }

		public event PropertyChangedEventHandler PropertyChanged;
		public event PropertyChangingEventHandler PropertyChanging;

		protected void OnPropertyChanged(string propertyName)
		{
			if (PropertyChanged != null)
			{
				PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}

		protected void OnPropertyChanging(string propertyName)
		{
			if (PropertyChanging != null)
			{
				PropertyChanging(this, new PropertyChangingEventArgs(propertyName));
			}
		}

		public void LoadLookupLabels(IOrganizationService service, bool isDeferred = false)
		{
			var properties = from propQ in this.GetType().GetProperties()
			                 let propIdQ = this.GetType().GetProperty(propQ.Name.Replace("Labels", ""))
			                 where Attribute.IsDefined(propQ, typeof(LabelAttribute))
			                       && (Guid?) propIdQ.GetValue(this) != null
			                 select new
			                        {
				                        property = propQ,
				                        id = propIdQ.GetValue(this),
				                        attribute = propQ.GetCustomAttribute<LabelAttribute>()
			                        };

			foreach (var property in properties)
			{
				var fields = property.attribute.LabelFieldNames.Split(',');

				var query = new QueryExpression(property.attribute.LogicalName);
				query.Criteria.AddCondition(property.attribute.IdFieldName, ConditionOperator.Equal, property.id);
				query.ColumnSet = new ColumnSet(fields.Select(field => field.Substring(5)).ToArray());

				var queryAction =
					new QueryAction(query)
					{
						Action =
							result =>
							{
								var response = result as RetrieveMultipleResponse;
								if (response == null) return;

								var entityQ = response.EntityCollection.Entities.FirstOrDefault();
								if (entityQ == null) return;

								var englishLabel = (string) entityQ.Attributes.FirstOrDefault(
									attribute => ("1033_" + attribute.Key) == fields.FirstOrDefault(field => field.Contains("1033_"))).Value;
								var dictionary = <#= Context.IsUseCustomDictionary ? "new List<OptionsetLanguageLabel>()" : "new Dictionary<int, string>()" #>;
								<#= Context.IsUseCustomDictionary ? "dictionary.Add(new OptionsetLanguageLabel { LanguageCode = 1033, OptionsetLabel = englishLabel })" : "dictionary[1033] = englishLabel" #>;
<# foreach (var lang in Context.Languages.Where(lang => lang != 1033)) { #>
								var langLabel = (string) entityQ.Attributes.FirstOrDefault(attribute =>
										("<#= lang #>_" + attribute.Key) == fields.FirstOrDefault(field => field.StartsWith("<#= lang #>_"))).Value
										        ?? englishLabel;
								<#= Context.IsUseCustomDictionary ? "dictionary.Add(new OptionsetLanguageLabel { LanguageCode = " + lang + ", OptionsetLabel = langLabel })" : "dictionary[" + lang + "] = langLabel" #>;
<# } #>
								property.property.SetValue(this, dictionary);
							}
					};

				if (isDeferred)
				{
					this.DeferredQueriesList.Add(queryAction);
				}
				else
				{
					queryAction.Action.Invoke(service.Execute(new RetrieveMultipleRequest{Query = query}));
				}
			}
		}

		#region Relationship methods

		protected override IEnumerable<TEntity> GetRelatedEntities<TEntity>(string relationshipSchemaName, EntityRole? primaryEntityRole)
		{
		    var key = new Relationship(relationshipSchemaName) { PrimaryEntityRole = primaryEntityRole };

			var enumerable = base.GetRelatedEntities<TEntity>(relationshipSchemaName, primaryEntityRole);

			if (ServiceContext != null && enumerable == null)
			{
				if (!ServiceContext.IsAttached(this))
				{
					throw new Exception("The context that loaded this entity must be used to load relationships, " +
										"or set 'MergeOption' to anything other than 'NoTracking' in the context before fetching this entity using LINQ.");
				}

				ServiceContext.LoadProperty(this, key);
			}

			enumerable = base.GetRelatedEntities<TEntity>(relationshipSchemaName, primaryEntityRole);
			
			if (enumerable == null)
			{
				if (backupRelatedEntityCollection != null && backupRelatedEntityCollection.Contains(key))
					enumerable = backupRelatedEntityCollection[key].Entities.Cast<TEntity>();
			}

			return enumerable;
		}

		protected override TEntity GetRelatedEntity<TEntity>(string relationshipSchemaName, EntityRole? primaryEntityRole)
		{
			var key = new Relationship(relationshipSchemaName) { PrimaryEntityRole = primaryEntityRole };

			var result = base.GetRelatedEntity<TEntity>(relationshipSchemaName, primaryEntityRole);

			if (ServiceContext != null && result == null)
			{
				if (!ServiceContext.IsAttached(this))
				{
					throw new Exception("The context that loaded this entity must be used to load relationships, " +
										"or set 'MergeOption' to anything other than 'NoTracking' in the context before fetching this entity using LINQ.");
				}

				ServiceContext.LoadProperty(this, key);
			}

			result = base.GetRelatedEntity<TEntity>(relationshipSchemaName, primaryEntityRole);

			if (result == null)
			{
				if (backupRelatedEntityCollection != null && backupRelatedEntityCollection.Contains(key))
					result = (TEntity)backupRelatedEntityCollection[key].Entities.FirstOrDefault();
			}
			
			return result;
		}

		#endregion
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public abstract class GeneratedEntity<TRelationName> : GeneratedEntityBase where TRelationName : RelationNameBase
	{
		public GeneratedEntity()
		{}

		public GeneratedEntity(string logicalName) : base(logicalName)
		{}

		#region Relationship methods

		/// <summary>
		/// Fetch the records related to this entity on this relationship. 
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public RelationPagingInfo LoadRelation(TRelationName relationName, IOrganizationService service, params string[] attributes)
		{
			return LoadRelation(relationName, service, false, -1, -1, null, null, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. 
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public RelationPagingInfo LoadRelation(TRelationName relationName, IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return LoadRelation(relationName, service, isDeferred, -1, -1, null, null, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public RelationPagingInfo LoadRelation(TRelationName relationName, IOrganizationService service, bool isDeferred, FilterExpression filter, params string[] attributes)
		{
			return LoadRelation(relationName, service, isDeferred, -1, -1, null, filter, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public RelationPagingInfo LoadRelation(TRelationName relationName, IOrganizationService service, bool isDeferred, int recordCountLimit, params string[] attributes)
		{
			return LoadRelation(relationName, service, isDeferred, recordCountLimit, -1, null, null, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public RelationPagingInfo LoadRelation(TRelationName relationName, IOrganizationService service, bool isDeferred, int recordCountLimit, int page, string cookie, params string[] attributes)
		{
			return LoadRelation(relationName, service, isDeferred, recordCountLimit, page, cookie, null, attributes);
		}

		/// <summary>
		/// Fetch the next page of records related to this entity on this relationship using the previous paging info object returned.
		/// </summary>
		public RelationPagingInfo LoadRelation(TRelationName relationName, IOrganizationService service, bool isDeferred, RelationPagingInfo pagingInfo, params string[] attributes)
		{
			return LoadRelation(relationName, service, isDeferred, pagingInfo.RecordCountLimit, pagingInfo.NextPage, pagingInfo.Cookie, pagingInfo.Filter, pagingInfo, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public RelationPagingInfo LoadRelation(TRelationName relationName, IOrganizationService service, bool isDeferred, int recordCountLimit, int page, string cookie, FilterExpression filter, params string[] attributes)
		{
			return LoadRelation(relationName, service, isDeferred, recordCountLimit, page, cookie, filter, null, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public RelationPagingInfo LoadRelation(TRelationName relationName, IOrganizationService service, bool isDeferred, int recordCountLimit, int page, string cookie, FilterExpression filter, RelationPagingInfo pagingInfo, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			if (!RelationProperties.ContainsKey(relationName.Name)) {
				throw new Exception("Relation does not exist in entity, or is not generated.");
			}
			var relationPagingInfo = pagingInfo ?? new RelationPagingInfo
				{
					RecordCountLimit = recordCountLimit,
					Filter = filter,
					Cookie = cookie,
					NextPage = page
				};
			var relationParams = RelationProperties[relationName.Name];
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, (string) relationParams[1], (string) relationParams[2], (string) relationParams[3], (string) relationParams[4], (string) relationParams[5], (string) relationParams[6],
					recordCountLimit, page, cookie, filter, attributes));
			var queryAction = queryActionObject.Action =
							  resultQ => {
								  var response = resultQ as RetrieveMultipleResponse;
								  var entityType = ((Type) relationParams[8]).GetElementType() ?? (Type) relationParams[8];
					              var resultArray = response == null ? ((List<Entity>) resultQ).Select(entityQ => entityQ.GetType().GetMethod("ToEntity").MakeGenericMethod(entityType).Invoke(entityQ, null)).ToArray()
	    				              : response.EntityCollection.Entities.Select(entityQ => entityQ.GetType().GetMethod("ToEntity").MakeGenericMethod(entityType).Invoke(entityQ, null)).ToArray();
					              var relatedRecords = Array.CreateInstance(entityType, resultArray.Length);
					              Array.Copy(resultArray, relatedRecords, resultArray.Length);
								  DeferredQueriesList.Remove(queryActionObject);
								  var newValue = relatedRecords.Length <= 0 ? null : (((Type) relationParams[8]).GetElementType() == null ? relatedRecords.GetValue(0) : relatedRecords);
								  GetType().GetProperty((string) relationParams[0]).SetValue(this, newValue);
							  };
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page, cookie, relationPagingInfo));
			return relationPagingInfo;
		}

		#endregion
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public class RelationPagingInfo
	{
		public string Cookie;
		public int NextPage = 1;
		public int RecordCountLimit = -1;
		public FilterExpression Filter;
		public bool IsMoreRecords = true;
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public abstract class RelationNameBase
	{
		public string Name;

		public RelationNameBase(string name)
		{
			Name = name;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	internal class QueryAction
	{
		public QueryExpression Query { get; set; }
		public Action<object> Action { get; set; }

		public QueryAction(QueryExpression query, Action<object> action = null)
		{
			Query = query;
			Action = action;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[AttributeUsage(AttributeTargets.Class)]
	public class CrmEntityMappingAttribute : Attribute
	{
		public string LogicalName { get; private set; }
		public string SchemaName { get; private set; }
		public string DisplayName { get; private set; }

		public CrmEntityMappingAttribute(string logicalName, string schemaName, string displayName = null)
		{
			if (string.IsNullOrWhiteSpace(logicalName))
			{
				throw new ArgumentNullException("logicalName");
			}

			if (string.IsNullOrWhiteSpace(schemaName))
			{
				throw new ArgumentNullException("schemaName");
			}

			LogicalName = logicalName;
			SchemaName = schemaName;
			DisplayName = displayName;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[AttributeUsage(AttributeTargets.Field)]
	public class ReadOnlyFieldAttribute : Attribute
	{}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[AttributeUsage(AttributeTargets.Field)]
	public class CrmFieldMappingAttribute : Attribute
	{
		public string LogicalName { get; private set; }
		public string RelatedEntity { get; private set; }

		public CrmFieldMappingAttribute(string logicalName, string relatedEntity = null)
		{
			if (string.IsNullOrWhiteSpace(logicalName))
			{
				throw new ArgumentNullException("logicalName");
			}

			LogicalName = logicalName;
			RelatedEntity = relatedEntity;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[AttributeUsage(AttributeTargets.Field)]
	public class CrmRelationMappingAttribute : Attribute
	{
		public string SchemaName { get; private set; }
		public Type RelatedEntityType { get; private set; }
		public EntityRole? Role { get; private set; }

		public CrmRelationMappingAttribute(string schemaName, Type relatedEntityType)
		{
			if (string.IsNullOrWhiteSpace(schemaName))
			{
				throw new ArgumentNullException("schemaName");
			}

			if (relatedEntityType == null)
			{
				throw new ArgumentNullException("relatedEntityType");
			}

			SchemaName = schemaName;
			RelatedEntityType = relatedEntityType;
		}

		public CrmRelationMappingAttribute(string schemaName, Type relatedEntityType, EntityRole role)
		{
			if (string.IsNullOrWhiteSpace(schemaName))
			{
				throw new ArgumentNullException("schemaName");
			}

			if (relatedEntityType == null)
			{
				throw new ArgumentNullException("relatedEntityType");
			}

			SchemaName = schemaName;
			RelatedEntityType = relatedEntityType;
			Role = role;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
	public class InRangeAttribute : Attribute
	{
		public string Min { get; set; }
		public string Max { get; set; }
		public Type Type { get; set; }

		public InRangeAttribute(string min, string max, Type type)
		{
			Min = min;
			Max = max;
			Type = type;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
	public class MaxLengthAttribute : Attribute
	{
		public int Max { get; set; }

		public MaxLengthAttribute(int max)
		{
			Max = max;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
	public class RequiredAttribute : Attribute
	{
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[AttributeUsage(AttributeTargets.Property)]
	public class LabelAttribute : Attribute
	{
		public string LabelFieldNames { get; set; }
		public string LogicalName { get; set; }
		public string IdFieldName { get; set; }
		public string FieldLogicalName { get; set; }

		public LabelAttribute(string labelFieldNames, string logicalName, string idFieldName, string fieldLogicalName)
		{
			LabelFieldNames = labelFieldNames;
			LogicalName = logicalName;
			IdFieldName = idFieldName;
			FieldLogicalName = fieldLogicalName;
		}
	}

	public enum ValidationType
	{
		Required,
		InRange,
		MaxLength
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public class OptionsetLanguageLabel
	{
		public int LanguageCode { get; set; }
		public string OptionsetLabel {get; set;}
	}

	public enum ClearMode
	{
		[EnumMember] Disabled,
		[EnumMember] Empty,
		[EnumMember] Convention,
		[EnumMember] Flag
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract]
	public partial class EntityContract
	{
		[DataMember] public virtual ClearMode? ValueClearMode { get { return ClearMode.<#= Context.ClearMode #>; } set{} }

		public TCrmEntity ConvertTo<TCrmEntity>(ClearMode? clearMode = null) where TCrmEntity : Entity
		{
			// create CRM entity object
			var crmRecord = Activator.CreateInstance<TCrmEntity>();

			var entityType = GetType();
			var entityLogicalName = entityType.GetCustomAttribute<CrmEntityMappingAttribute>().LogicalName;

			// if logical names don't match
			if (entityLogicalName != crmRecord.LogicalName)
			{
				throw new Exception(string.Format("Entity '{0}' doesn't map to CRM entity '{1}'.",
					entityType.Name, typeof(TCrmEntity).Name));
			}
            
            clearMode = clearMode ?? (ClearMode?) entityType.GetProperty("ValueClearMode").GetValue(this) ?? ClearMode.<#= Context.ClearMode #>;

			// go over all fields in the contract entity that has the mapping attribute
			foreach (var field in entityType.GetFields()
				.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof(CrmFieldMappingAttribute))
								 && !Attribute.IsDefined(fieldQ, typeof(CrmRelationMappingAttribute))))
			{
				// get the value of the mapping attribute
				var mapping = field.GetCustomAttribute<CrmFieldMappingAttribute>();
				// get the value of the field
				var value = field.GetValue(this);
				// is the field value read only
				var isReadOnly = field.GetCustomAttribute<ReadOnlyFieldAttribute>() != null;
                // get the clear flag mode value if it exists
                var isClearFlag = value == null && clearMode == ClearMode.Flag
                    && (bool?)entityType.GetFields().Where(fieldQ => fieldQ.Name == "Clear_" + field.Name)
                    .Select(fieldQ => fieldQ.GetValue(this)).FirstOrDefault() == true;
                // check 'empty' mode
                var isClearEmpty = value == null && clearMode == ClearMode.Empty;

                var isSetValue = (value != null && !isReadOnly) || isClearFlag || isClearEmpty;

                // skip if no value and clear mode does not match and pass check
                if (isReadOnly || !isSetValue)
				{
					continue;
				}

				SetValueInCrmRecord(value, crmRecord, field.Name, mapping, clearMode);
			}

			// go over flattened relations in the contract entity that has the mapping attribute
			foreach (var field in GetType().GetFields()
				.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof(CrmRelationMappingAttribute))
					&& Attribute.IsDefined(fieldQ, typeof(CrmFieldMappingAttribute))))
			{
				// get the value of the field
				var value = field.GetValue(this);
				// is the field value read only
				var isReadOnly = field.GetCustomAttribute<ReadOnlyFieldAttribute>();

				// skip if no value
				if (isReadOnly != null || (value == null && clearMode != ClearMode.Empty) || value is Array)
				{
					continue;
				}

				SetRelationInRecord(value, field);
			}
			// go over all relations in the contract entity that has the mapping attribute
			foreach (var relation in GetType().GetFields()
				.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof(CrmRelationMappingAttribute))
					&& !Attribute.IsDefined(fieldQ, typeof(CrmFieldMappingAttribute))))
			{
				// get the value of the mapping attribute
				var mapping = relation.GetCustomAttribute<CrmRelationMappingAttribute>();
				// get the value of the field
				var value = relation.GetValue(this);
				// is the relation read only
				var isReadOnly = relation.GetCustomAttribute<ReadOnlyFieldAttribute>();

				// skip if no value
				if (isReadOnly != null || value == null || (value is Array && ((Array)value).Length <= 0))
				{
					continue;
				}

				SetRelationInCrmRecord(value, crmRecord, mapping, clearMode);
			}

			return crmRecord;
		}

		private void SetRelationInRecord(object value, FieldInfo fieldInfo)
		{
			var fields = GetType().GetFields()
				.Where(fieldQ => Attribute.IsDefined(fieldQ, typeof (CrmRelationMappingAttribute))
				                 && !Attribute.IsDefined(fieldQ, typeof (CrmFieldMappingAttribute)));
			// get the field representing the relationship
			var relation = fields.First(fieldQ => fieldQ.Name == fieldInfo.Name.Split('_')[0]);
			// get the related entity type
			var fieldType = relation.FieldType;
			// get the target field in the related entity to set the value
			var field = fieldType.GetFields().First(fieldQ => fieldQ.Name == fieldInfo.Name.Substring(relation.Name.Length + 1));

			// get the relation value
			var record = relation.GetValue(this);

			if (record == null)
			{
				// create a new instance of the related entity if it's null
				record = Activator.CreateInstance(fieldType);
				// save the relation object in this entity
				relation.SetValue(this, record);
			}

			// set the field value in the related record
			field.SetValue(record, value);
		}

		private static void SetValueInCrmRecord<TCrmEntity>(object value, TCrmEntity crmRecord,
			string fieldName, CrmFieldMappingAttribute mapping, ClearMode? clearMode = null)
			where TCrmEntity : Entity
		{
			var crmProperty = GetCrmProperty<TCrmEntity>(mapping);

			// if property not found, then the entities don't map correctly
			if (crmProperty == null)
			{
				throw new Exception(string.Format("Entity doesn't map to CRM entity '{0}'.",
					typeof(TCrmEntity).Name));
			}
            
			// if no value, and clear mode is global, then clear
			if (value == null && clearMode == ClearMode.Empty)
			{
				crmRecord[mapping.LogicalName] = null;
			}
            
			// convert types
			if (value is Enum)
			{
			    // if clear mode is convention, and value fits convention, then clear
				crmRecord[mapping.LogicalName] = (((int) value) == -1 && clearMode == ClearMode.Convention) ? null : new OptionSetValue((int) value);
			}
			else if (value is decimal? && crmProperty.PropertyType == typeof(Money))
			{
				crmRecord[mapping.LogicalName] = (value.Equals(decimal.MinValue) && clearMode == ClearMode.Convention) ? null : new Money(((decimal?) value).Value);
			}
			else if (value is Guid? && fieldName != "Id"
					 && crmProperty.PropertyType != typeof(EntityReference))
			{
				crmProperty.SetValue(crmRecord, (value.Equals(Guid.Empty) && clearMode == ClearMode.Convention) ? null : (Guid?) value);
			}
			else
			{
			    // if clear mode is convention, and value fits convention, then clear
			    if (clearMode == ClearMode.Convention
                    && ((value is DateTime? && value.Equals(new DateTime(1970, 1, 1)))
                        || (value is int? && value.Equals(int.MinValue))
                        || (value is long? && value.Equals(long.MinValue))
                        || (value is decimal? && value.Equals(decimal.MinValue))
                        || (value is double? && value.Equals(double.MinValue))
                        || (value is string && value.Equals(""))))
			    {
				    crmProperty.SetValue(crmRecord, null);
			    }
                else
				{
                    crmProperty.SetValue(crmRecord, value);
                }
			}
		}

		/// <summary>
		///     Gets the property from the CRM entity that corresponds to this field -- same mapping
		/// </summary>
		/// <typeparam name="TCrmEntity">The type of the entity.</typeparam>
		/// <param name="mapping">The mapping.</param>
		/// <returns></returns>
		private static PropertyInfo GetCrmProperty<TCrmEntity>(CrmFieldMappingAttribute mapping)
			where TCrmEntity : Entity
		{
			var crmProperty = typeof(TCrmEntity).GetProperties()
				.FirstOrDefault(propertyQ =>
								{
									var fieldAttribute = propertyQ
										.GetCustomAttributes<AttributeLogicalNameAttribute>(true)
										.FirstOrDefault();

									return fieldAttribute != null
										   && fieldAttribute.LogicalName == mapping.LogicalName;
								});

			return crmProperty;
		}

		private static void SetRelationInCrmRecord<TCrmEntity>(object value, TCrmEntity crmRecord,
			CrmRelationMappingAttribute mapping, ClearMode? clearMode = null)
			where TCrmEntity : Entity
		{
			var crmRelation = GetCrmRelation<TCrmEntity>(mapping);

			// if relation not found, then the entities don't map correctly
			if (crmRelation == null)
			{
				throw new Exception(string.Format("Entity doesn't map to CRM entity '{0}'.",
					typeof(TCrmEntity).Name));
			}

			object convertedValue = null;

			// x-N relation
			if (value is Array)
			{
				var relatedRecords = (Array)value;
				// create an array for the related entities of the appropriate type
				var crmRelatedRecords = Array.CreateInstance(mapping.RelatedEntityType, relatedRecords.Length);

				// create the method reference that will be used to convert the related entities to the CRM entities
				var method = GetConversionMethod(relatedRecords.GetValue(0), mapping.RelatedEntityType);

				// convert all entities to CRM entities
				var objectCrmRelatedRecords = (from object relatedRecord in relatedRecords
											   select method.Invoke(relatedRecord, new object[] { clearMode })).ToArray();

				// copy the object entities to the array of the specific type
				Array.Copy(objectCrmRelatedRecords, crmRelatedRecords, crmRelatedRecords.Length);
				convertedValue = crmRelatedRecords;
			}
			else if (value is EntityContract)
			{
				// N-1 relation
				var method = GetConversionMethod(value, mapping.RelatedEntityType);
				convertedValue = method.Invoke(value, new object[] { clearMode });
			}

			// set the related entities value in the CRM entity
			crmRelation.SetValue(crmRecord, convertedValue);
		}

		private static MethodInfo GetConversionMethod(object entity, Type relatedType)
		{
			return entity.GetType().GetMethod("ConvertTo")
				.MakeGenericMethod(relatedType);
		}

		/// <summary>
		///     Gets the relation from the CRM entity that corresponds to this relation -- same mapping
		/// </summary>
		/// <typeparam name="TCrmEntity">The type of the entity.</typeparam>
		/// <param name="mapping">The mapping.</param>
		/// <returns></returns>
		private static PropertyInfo GetCrmRelation<TCrmEntity>(CrmRelationMappingAttribute mapping)
			where TCrmEntity : Entity
		{
			var crmRelation = typeof(TCrmEntity).GetProperties()
				.FirstOrDefault(propertyQ =>
								{
									var relationAttribute = propertyQ
										.GetCustomAttributes<RelationshipSchemaNameAttribute>(true)
										.FirstOrDefault();

									return relationAttribute != null
										   && relationAttribute.SchemaName == mapping.SchemaName
										   && relationAttribute.PrimaryEntityRole == mapping.Role;
								});

			return crmRelation;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public static partial class GeneratorHelpers
	{
		#region Enums

		/// <summary>
		/// Get the value that corresponds to the label from the option-set,
		/// using the type of the class enclosing both, label type, and the language code given.
		/// </summary>
		/// <param name="labelType">The type of the class containing the labels; e.g.: 'typeof(Account.Enums.Labels.IndustryCode)'</param>
		/// <param name="label">The label to search for, corresponding to the value</param>
		/// <param name="languageCode">The language code from CRM</param>
		/// <returns>The value corresponding to the label</returns>
		public static int GetValue(Type labelType, string label, int languageCode = 1033)
		{
			var labelsType = labelType.DeclaringType;

			if (labelsType == null)
			{
				return -1;
			}

			var enumsType = labelsType.DeclaringType;

			if (enumsType == null)
			{
				return -1;
			}

			// get the fields with the same label from the label class
			var fields = labelType.GetFields()
				.Where(fieldQ => fieldQ.Name.Contains(languageCode.ToString())
					&& (string)fieldQ.GetValue(labelType) == label);

			if (!fields.Any())
			{
				return -1;
			}

			var field = fields.First();

			var entityType = enumsType.DeclaringType;

			if (entityType == null)
			{
				return -1;
			}

			var enumType = entityType.GetNestedType(labelType.Name + "Enum");

			if (enumType == null)
			{
				return -1;
			}

			// get the enum constant corresponding to the field name
			var enumConstant = Enum.Parse(enumType, field.Name.Replace("_" + languageCode, ""));

			return (int)enumConstant;
		}

		/// <summary>
		/// Gets the value corresponding to the option-set's label using its logical name,
		/// the value within, and the language code.
		/// </summary>
		/// <param name="logicalName">The logical name of the option-set in CRM</param>
		/// <param name="label">The label from the option-set</param>
		/// <param name="enumsType">The 'Enums' type; e.g.: 'typeof(Account.Enums)'</param>
		/// <param name="languageCode">The language code from CRM</param>
		/// <returns>The value corresponding to the label</returns>
		public static int GetValue(string logicalName, string label, Type enumsType, int languageCode = 1033)
		{
			var labelType = GetLabelType(enumsType, logicalName);

			return GetValue(labelType, label, languageCode);
		}

		private static Type GetEnumType(Type enumsType, string logicalName)
		{
			var field = GetLogicalNameField(enumsType, logicalName);

			var entityType = enumsType.DeclaringType;

			if (entityType == null)
			{
				throw new Exception("Can't find the entity type from the enum type.");
			}

			return field == null ? null : entityType.GetNestedType(field.Name + "Enum");
		}

		#endregion

		#region Labels

		/// <summary>
		/// Gets the label corresponding to the option-set's value using its logical name,
		/// the value within, and the language code.
		/// </summary>
		/// <param name="logicalName">The logical name of the option-set in CRM</param>
		/// <param name="constant">The value from the option-set</param>
		/// <param name="enumsType">The 'Enums' type; e.g.: 'typeof(Account.Enums)'</param>
		/// <param name="languageCode">The language code from CRM</param>
		/// <returns></returns>
		public static string GetLabel(string logicalName, int constant, Type enumsType, int languageCode = 1033)
		{
			var enumType = GetEnumType(enumsType, logicalName);

			if (enumType == null)
			{
				return "NO_LABEL";
			}

			var enumName = enumType.Name;
			var constantName = enumType.GetEnumName(constant);
			var labelsType = enumsType.GetNestedType("Labels");

			if (labelsType == null)
			{
				return "NO_LABEL";
			}

			var labelType = labelsType.GetNestedType(enumName.Substring(0, enumType.Name.LastIndexOf("Enum")));

			if (labelType == null)
			{
				return "NO_LABEL";
			}

			var field = labelType.GetField(constantName + "_" + languageCode);

			return field == null ? "NO_LABEL" : field.GetValue(labelType).ToString();
		}

		private static Type GetLabelType(Type enumsType, string logicalName)
		{
			var field = GetLogicalNameField(enumsType, logicalName);
			return enumsType.GetNestedType("Labels").GetNestedType(field.Name);
		}

		#endregion

		private static FieldInfo GetLogicalNameField(Type enumsType, string logicalName)
		{
			var namesType = enumsType.GetNestedType("Names");
			return namesType.GetFields().FirstOrDefault(fieldQ => (string)fieldQ.GetValue(namesType) == logicalName);
		}

		internal static QueryExpression GetLoadRelationQuery(Entity entity, IOrganizationService service,
			string fromEntityName, string toEntityName, string fromFieldName, string toFieldName,
			string idFieldName, string intersectIdFieldName, int limit = -1, int page = -1, string cookie = null,
			FilterExpression filter = null, params string[] attributes)
		{
			limit = limit <= 0 ? int.MaxValue : limit;

			// create the query taking into account paging
			var query = new QueryExpression(fromEntityName);
			query.LinkEntities.Add(new LinkEntity(fromEntityName, toEntityName, fromFieldName, toFieldName, JoinOperator.Inner));
			query.LinkEntities[0].EntityAlias = "linkedEntityAlias";
			query.Criteria.AddCondition("linkedEntityAlias", intersectIdFieldName, ConditionOperator.Equal, entity[idFieldName]);

			if (filter != null)
			{
				query.Criteria.AddFilter(filter);
			}

			if (attributes.Length == 1 && attributes[0] == "*")
			{
				query.ColumnSet = new ColumnSet(true);
			}
			else if (attributes.Length > 0)
			{
				query.ColumnSet = new ColumnSet(attributes);
			}
			else
			{
				query.ColumnSet = new ColumnSet(false);
			}

			query.PageInfo = new PagingInfo
			{
				PageNumber = page <= 0 ? 1 : page,
				Count = limit,
				PagingCookie = cookie
			};

			return query;
		}

		internal static List<Entity> LoadRelation(Entity entity, IOrganizationService service,
			string fromEntityName, string toEntityName, string fromFieldName, string toFieldName,
			string idFieldName, string intersectIdFieldName, int limit = -1, int page = -1,
			FilterExpression filter = null, string cookie = null, RelationPagingInfo relationPagingInfo = null, params string[] attributes)
		{
			return LoadRelation(service, GetLoadRelationQuery(entity, service, fromEntityName, toEntityName,
				fromFieldName, toFieldName, idFieldName, intersectIdFieldName, limit, page, cookie,
				filter, attributes), limit, page, cookie, relationPagingInfo);
		}

		public static List<Entity> LoadRelation(IOrganizationService service, QueryExpression query,
			int limit = -1, int page = -1, string cookie = null, RelationPagingInfo relationPagingInfo = null)
		{
			limit = limit <= 0 ? int.MaxValue : limit;
			query.PageInfo = query.PageInfo ??
				new PagingInfo
				{
					PageNumber = page <= 0 ? 1 : page,
					Count = limit
				};
			query.PageInfo.PagingCookie = cookie ?? relationPagingInfo.Cookie ?? query.PageInfo.PagingCookie;

			EntityCollection records;
			var entities = new List<Entity>();

			// get all records
			do
			{
				// fetch the records
				records = service.RetrieveMultiple(query);

				// next time get the next bundle of records
				query.PageInfo.PagingCookie = records.PagingCookie;
				query.PageInfo.PageNumber++;

				// add to existing list
				entities.AddRange(records.Entities);
			} while (records.MoreRecords && entities.Count < limit && page <= 0);

			if (relationPagingInfo != null)
			{
				relationPagingInfo.Cookie = query.PageInfo.PagingCookie;
				relationPagingInfo.NextPage = query.PageInfo.PageNumber;
				relationPagingInfo.IsMoreRecords = records.MoreRecords;
			}

			return entities.ToList();
		}

		/// <summary>
		/// Executes the queries in the query queue in each entity passed, and executes the action related to the query after.<br />
		/// Returns a list of errors per entity processed.
		/// </summary>
		/// <param name="service">CRM service to use to execute query.</param>
		/// <param name="entities">List of entities containing the queues.</param>
		public static IDictionary<GeneratedEntityBase, IList<string>> ProcessDeferredQueries(IOrganizationService service,
			params GeneratedEntityBase[] entities)
		{
            return ProcessDeferredQueries(service, 100, entities);
        }

		/// <summary>
		/// Executes the queries in the query queue in each entity passed, and executes the action related to the query after.<br />
		/// Returns a list of errors per entity processed.
		/// </summary>
		/// <param name="service">CRM service to use to execute query.</param>
		/// <param name="bulkSize">The number of requests from the queue to execute in each iteration.</param>
		/// <param name="entities">List of entities containing the queues.</param>
		internal static IDictionary<GeneratedEntityBase, IList<string>> ProcessDeferredQueries(IOrganizationService service,
			int bulkSize, params GeneratedEntityBase[] entities)
		{
			var errorList = new Dictionary<GeneratedEntityBase, IList<string>>();

			// exit if no entities to process
			if (!entities.Any()) return errorList;
            
            bulkSize = Math.Min(1000, bulkSize);

			// filter entities to only the ones with a queue
			entities = entities.Where(entity => entity.DeferredQueriesList.Any()).ToArray();

			// queue to assign errors to proper entity and to find the original query and invoke the action
			var queryActionQueue = new Queue<KeyValuePair<GeneratedEntityBase, QueryAction>>();

			// create a queue to support paging in bulk execution
			var requestsQueue = new Queue<OrganizationRequest>();

			// go over the entities and fill the queues
			foreach (var entity in entities)
			{
				foreach (var queryAction in entity.DeferredQueriesList)
				{
					queryActionQueue.Enqueue(new KeyValuePair<GeneratedEntityBase, QueryAction>(entity, queryAction));
					requestsQueue.Enqueue(new RetrieveMultipleRequest {Query = queryAction.Query});
				}
			}

			var bulkQuery = new ExecuteMultipleRequest
			{
				Settings = new ExecuteMultipleSettings
				{
					ContinueOnError = true,
					ReturnResponses = true
				},
				Requests = new OrganizationRequestCollection()
			};

			while (requestsQueue.Any())
			{
				bulkQuery.Requests.Clear();

				// page execution
				do
				{
					bulkQuery.Requests.Add(requestsQueue.Dequeue());
				} while (bulkQuery.Requests.Count % bulkSize != 0 && requestsQueue.Any());

				var result = (ExecuteMultipleResponse) service.Execute(bulkQuery);

				foreach (var response in result.Responses)
				{
					var queryAction = queryActionQueue.Dequeue();
					var entity = queryAction.Key;

					// parse fault
					if (response.Fault != null)
					{
						if (!errorList.ContainsKey(entity))
						{
							errorList.Add(entity, new List<string>());
						}

						errorList[entity].Add(string.Format("Error code: {0}.\nError message: {1}.",
							response.Fault.ErrorCode, response.Fault.Message)
													 + (!string.IsNullOrEmpty(response.Fault.TraceText)
															? "\nError trace: " + response.Fault.TraceText
															: ""));

						continue;
					}

					queryAction.Value.Action.Invoke(response.Response);
				}
			}

			return errorList;
		}
	}

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
    public class EntityComparer : IEqualityComparer<Entity>
    {
        public bool Equals(Entity x, Entity y)
        {
            return x.Id == y.Id;
        }

        public int GetHashCode(Entity obj)
        {
            return obj.Id.GetHashCode();
        }
    }

	#endregion

<# if (Context.GenerateGlobalActions && Context.GlobalActions.Any()) { #>
	#region Global Actions

	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	public static class GlobalActions
	{
<#	ParseActions(Context.GlobalActions); #>

	}

	#endregion

<# } #>
	#region Actions

<# foreach (var entity in Context.Entities.Where(entity => entity.Actions.Any() && Context.ActionEntities.Contains(entity.LogicalName))) {
        var entityFilterList = Context.EntityDataFilterArray;
        var entityFilter = entityFilterList.EntityFilters.First(filter => filter.IsDefault)
			.EntityFilterList.First(filter => filter.LogicalName == entity.LogicalName);
        var crmEntityName = entityFilter.EntityRename ?? (Context.UseDisplayNames ? entity.FriendlyName : entity.HybridName);
#>
	public partial class <#= crmEntityName #>
	{
		public static class Actions
		{
<#	ParseActions(entity.Actions); #>
		}
	}

<# } #>
	#endregion

	#region Known Types
<# 
    List<string> KnownTypes = new List<string>();

	foreach (var entity in Context.Entities)
    {
        var entityFilterList = Context.EntityDataFilterArray;
        var entityFilter = entityFilterList.EntityFilters.First(filter => filter.IsDefault)
		    .EntityFilterList.First(filter => filter.LogicalName == entity.LogicalName);

        foreach (var entityFilterT in entityFilterList.EntityFilters
            .Where(entityFilterT => !entityFilterT.EntityFilterList.First(filter => filter.LogicalName == entity.LogicalName).IsExcluded)) { 
            var prefix = entityFilterT.Prefix;
            var suffix = entityFilterT.Suffix;
            var entityFilterQ = entityFilterT.EntityFilterList.First(filter => filter.LogicalName == entity.LogicalName);
            var crmEntityName = entityFilter.EntityRename ?? (Context.UseDisplayNames ? entity.FriendlyName : entity.HybridName);
            var contractEntityName =  entityFilterQ.EntityRename ?? crmEntityName;

            KnownTypes.Add(prefix + contractEntityName + suffix);
        }
    }

 if (KnownTypes.Any()) {
#>

	[<#= "KnownType(typeof(" + KnownTypes.Distinct().Aggregate((type1, type2) => type1 + ")),\r\n\t\tKnownType(typeof(" + type2) + "))" #>]
	public partial class EntityContract
	{
	}
<# } #>

	#endregion

	#region Entities
<#
	var manager = Manager.Create(Host, GenerationEnvironment);
#>
<#
	Generate(manager);
#>
<#+
	void Generate(Manager manager, MappingEntity entity)
	{
        var oneNRels= entity.RelationshipsOneToMany.Where(r => Context.Entities.Select(m => m.LogicalName).Contains(r.Type));
		var nOneRels = entity.RelationshipsManyToOne.Where(r => Context.Entities.Select(m => m.LogicalName).Contains(r.Type));
    var nNRels = entity.RelationshipsManyToMany.Where(r => Context.Entities.Select(m => m.LogicalName).Contains(r.Type));
       var entityFilterList = Context.EntityDataFilterArray;
        var entityFilter = entityFilterList.EntityFilters.First(filter => filter.IsDefault)
			.EntityFilterList.First(filter => filter.LogicalName == entity.LogicalName);
        var crmEntityName = entityFilter.EntityRename ?? (Context.UseDisplayNames ? entity.FriendlyName : entity.HybridName);
		manager.StartNewFile(Context.FileName + "_" + crmEntityName + ".cs");
#>
<#+	if (Context.SplitFiles) { #>
//         Project / File: <#= Context.Namespace #> / <#= Context.FileName #>.cs
// File generated by: CRM Code Generator - Eric Labashosky, Ahmed el-Sawalhy

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;
using System.Reflection;
using System.ServiceModel;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Client;
using Microsoft.Xrm.Sdk.Messages;
using Microsoft.Xrm.Sdk.Query;

namespace <#= Context.Namespace #><#+ if (Context.FileName != "CrmSchema") { #>.<#= Context.FileName #><#+}#>

{
	#region Entities
<#+}#>

	#region <#= crmEntityName #>

	/// <summary>
	/// '<#= entity.SchemaName #>'.<br />
	/// <#= entity.DescriptionXmlSafe.Replace("\n","").Replace("\r", " \r\n\t/// ") #>
	/// </summary>
	[ExcludeFromCodeCoverage]
	[DebuggerNonUserCode]
	[DataContract, EntityLogicalName("<#=entity.LogicalName#>")]
	public partial class <#= crmEntityName #> : GeneratedEntity<<#= crmEntityName #>.RelationName>
	{
		
		public <#= crmEntityName #>() : 
				base(EntityLogicalName)
		{
		}
		
		public const string DisplayName = <#=ToLiteral(entity.Label)#>;
		public const string SchemaName = "<#=entity.SchemaName#>";
		public const string EntityLogicalName = "<#=entity.LogicalName#>";
		public const int EntityTypeCode = <#=entity.TypeCode#>;
		
		public class RelationName : RelationNameBase
		{
			public RelationName(string name) : base(name)
			{}
		}

<#+ if (Context.JsEarlyBoundEntities.Contains(entity.LogicalName)) { #>

		#region Attributes

		[AttributeLogicalName("<#= entity.PrimaryKey.LogicalName #>"), DataMember]
		public override System.Guid Id
		{
<#+ var primaryAttribute = Context.UseDisplayNames
		? (FirstNotNullOrEmpty(entityFilter.AttributeRenames, entity.PrimaryKey.LogicalName) ?? entity.PrimaryKey.FriendlyName) : entity.PrimaryKey.DisplayName; #>
			get
			{
				return (<#= primaryAttribute #> == null || <#= primaryAttribute #> == Guid.Empty) ? base.Id : <#= primaryAttribute #>.GetValueOrDefault();
			}
			
			set
			{
                if (value == Guid.Empty) {
                    Attributes.Remove("<#= entity.PrimaryKey.LogicalName #>");
                    base.Id = value;
                } else {
				    <#= primaryAttribute #> = value;
                }
			}
		}

<#+	foreach(var attribute in entity.Fields.Where(fieldQ => !fieldQ.Attribute.IsEntityReferenceHelper && fieldQ.IsValidForRead))	{
            var attributeName = Context.UseDisplayNames ? (FirstNotNullOrEmpty(entityFilter.AttributeRenames, attribute.Attribute.LogicalName) ?? attribute.FriendlyName) : attribute.DisplayName;

            string attributeType = null;

            if (attribute.TargetTypeForCrmSvcUtil.Contains("EntityReference") && string.IsNullOrEmpty(attribute.LookupSingleType))
            {
                attributeType = "EntityReference";
            }
            else if (attribute.TargetTypeForCrmSvcUtil.Contains("OptionSetValue") || attribute.IsStateCode)
            {
               attributeType = attributeName + "Enum?";
            }
            else
            {
                attributeType = ConvertToContractType(attribute);
            }
#>

<#+ if(attribute.Description != "") { #>
        /// <summary>
        /// <#+ if (attribute.IsRequired) { #>[Required]<#+ } #><#+ if (attribute.MaxLength != null) { #>[MaximumLength=<#=attribute.MaxLength#>]<#+ } #><#+ if (attribute.Min != null && attribute.Max != null) { #>[Range(<#=attribute.Min#>, <#=attribute.Max#>)]<#+ } #> 
		/// '<#= attribute.SchemaName #>'.<br />
        /// <#= attribute.DescriptionXmlSafe.Replace("\n","").Replace("\r", " \r\n\t\t/// ") #>
        /// </summary>
<#+ } #>
		[AttributeLogicalName("<#=attribute.Attribute.LogicalName#>")<#+ if (entityFilter == null || entityFilter.Attributes == null || entityFilter.Attributes.Contains(attribute.Attribute.LogicalName)) { #>, DataMember<#+ } #><#+ if (attribute.IsRequired) { #>, Required<#+ } #><#+ if (attribute.MaxLength != null) { #>, MaxLength(<#= attribute.MaxLength #>)<#+ } #><#+ if (attribute.Min != null && attribute.Max != null) { #>, InRange("<#= attribute.Min #>", "<#= attribute.Max #>", typeof(<#= attributeType.Replace("?","") #>))<#+ } #>]
<#+ if(attribute.IsDeprecated) { #>
		[Obsolete]
<#+ } #>
		public <#= attributeType #> <#= attributeName #>
		{
<#+ if(attribute.IsActivityParty) { #>
			get
			{
				var collection = GetAttributeValue<EntityCollection>("<#=attribute.Attribute.LogicalName#>");
				if (collection == null && backupAttributeCollection != null && backupAttributeCollection.Contains("<#= attribute.Attribute.LogicalName #>"))
				    collection = (EntityCollection) backupAttributeCollection["<#= attribute.Attribute.LogicalName #>"];
				if (collection != null && collection.Entities != null)
					return collection.Entities.Select(entity => entity.ToEntity<ActivityParty>()).ToArray();
				else
					return null;
			}
			set
			{
				OnPropertyChanging("<#= attributeName #>");
				SetAttributeValue("<#= attribute.Attribute.LogicalName #>", new EntityCollection(new List<Entity>(value)));
				OnPropertyChanged("<#= attributeName #>");
			}
<#+ } else { #>
			get
			{
				var value = GetAttributeValue<<#= attribute.IsStateCode ? "OptionSetValue" : attribute.TargetTypeForCrmSvcUtil #>>("<#= attribute.Attribute.LogicalName #>");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("<#= attribute.Attribute.LogicalName #>"))
				    value = (<#= attribute.IsStateCode ? "OptionSetValue" : attribute.TargetTypeForCrmSvcUtil #>) backupAttributeCollection["<#= attribute.Attribute.LogicalName #>"];
<#+ if(attribute.TargetTypeForCrmSvcUtil.Contains("OptionSetValue") || attribute.IsStateCode) { #>
                return value == null ? (<#= attributeType #>) null : (<#= attributeType #>) value.Value;
<#+ } else if (attribute.TargetTypeForCrmSvcUtil.Contains("Money")) { #>
                return value == null ? (<#= attributeType #>) null : value.Value;
<#+ } else if (attribute.TargetTypeForCrmSvcUtil.Contains("EntityReference") && !attributeType.Contains("EntityReference")) { #>
                return value == null ? (<#= attributeType #>) null : value.Id;
<#+ } else { #>
			    return value;
<#+ } #>
			}
<#+ // if(attribute.IsValidForUpdate == true || attribute.IsValidForCreate == true || attribute == entity.PrimaryKey) { #>
			set
			{
				OnPropertyChanging("<#= attributeName #>");
<#+ if(attribute.TargetTypeForCrmSvcUtil.Contains("OptionSetValue") || attribute.IsStateCode) { #>
                if (value != null)
				    SetAttributeValue("<#= attribute.Attribute.LogicalName #>", new OptionSetValue((int) value.Value));
                else
<#+ } else if (attribute.TargetTypeForCrmSvcUtil.Contains("Money")) { #>
                if (value != null)
				    SetAttributeValue("<#= attribute.Attribute.LogicalName #>", new Money(value.Value));
                else
<#+ } else if (attribute.TargetTypeForCrmSvcUtil.Contains("EntityReference") && !attributeType.Contains("EntityReference")) { #>
                if (value != null)
				    SetAttributeValue("<#= attribute.Attribute.LogicalName #>", new EntityReference("<#= attribute.LookupSingleType #>", value.Value));
                else
<#+ } #>
<#+ if(attribute == entity.PrimaryKey) { #>
                if (value != null)
<#+ } #>
					SetAttributeValue("<#= attribute.Attribute.LogicalName #>", value);
<#+ if(attribute == entity.PrimaryKey) { #>
				if (value != null)
					base.Id = value.Value;
				else
					Id = System.Guid.Empty;
<#+ } #>
				OnPropertyChanged("<#= attributeName #>");
			}
<#+ } #>
		}

<#+ if (attribute.TargetTypeForCrmSvcUtil.Contains("EntityReference")) { #>
<#+ if (entityFilter == null || entityFilter.Attributes == null || entityFilter.Attributes.Contains(attribute.Attribute.LogicalName)) { #>
        [DataMember]
<#+ } #>
        public string <#= attributeName #>Name
        {
		    get
		    {
				var value = GetAttributeValue<<#= attribute.TargetTypeForCrmSvcUtil #>>("<#= attribute.Attribute.LogicalName #>");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("<#= attribute.Attribute.LogicalName #>"))
				    value = (<#= attribute.TargetTypeForCrmSvcUtil #>) backupAttributeCollection["<#= attribute.Attribute.LogicalName #>"];
                return value == null ? (string) null : value.Name;
            }
            set
            {}
        }

<#+ if (Context.LookupLabelsEntities != null && Context.LookupLabelsEntities.Contains(entity.LogicalName)) { #>
<#+ if (entityFilter == null || entityFilter.Attributes == null || entityFilter.Attributes.Contains(attribute.Attribute.LogicalName)) { #>
        [DataMember]
<#+ } #>
<#+ if (attribute.LookupLabel != null && !string.IsNullOrEmpty(attribute.LookupLabel.LabelFieldNames)) { #>
		[Label("<#= attribute.LookupLabel.LabelFieldNames #>", "<#= attribute.LookupLabel.LogicalName #>", "<#= attribute.LookupLabel.IdFieldName #>", "<#=attribute.Attribute.LogicalName#>")]
<#+ } #>
        public <#= Context.IsUseCustomDictionary ? "List<OptionsetLanguageLabel>" : "IDictionary<int, string>" #> <#= attributeName #>Labels { get; set; }

<#+ } #>
<#+ } #>
<#+ if (Context.OptionsetLabelsEntities != null && Context.OptionsetLabelsEntities.Contains(entity.LogicalName) && (attribute.TargetTypeForCrmSvcUtil.Contains("OptionSetValue") || attribute.TargetTypeForCrmSvcUtil.Contains("bool?") || attribute.IsStateCode) && entity.Enums.Any()) { #>
<#+     var enm = entity.Enums.FirstOrDefault(field => field.LogicalName == attribute.LogicalName);
		if (enm != null && enm.Items.Any())
		{
			var languages = enm.Items.First().LocalizedLabels.Select(label => label.LanguageCode);
 #>
<#+ if (entityFilter == null || entityFilter.Attributes == null || entityFilter.Attributes.Contains(attribute.Attribute.LogicalName)) { #>
        [DataMember]
<#+ } #>
        public <#= Context.IsUseCustomDictionary ? "List<OptionsetLanguageLabel>" : "IDictionary<int, string>" #> <#= attributeName #>Labels
        {
		    get
		    {
                var value = GetAttributeValue<<#= attribute.IsStateCode ? "OptionSetValue" : attribute.TargetTypeForCrmSvcUtil #>>("<#= attribute.Attribute.LogicalName #>");
				if (value == null && backupAttributeCollection != null && backupAttributeCollection.Contains("<#= attribute.Attribute.LogicalName #>"))
				    value = (<#= attribute.IsStateCode ? "OptionSetValue" : attribute.TargetTypeForCrmSvcUtil #>) backupAttributeCollection["<#= attribute.Attribute.LogicalName #>"];
                if (value == null)
                    return null;
                return new <#= Context.IsUseCustomDictionary ? "List<OptionsetLanguageLabel>" : "Dictionary<int, string>" #>
                        {
<#+ foreach(var language in languages) { #>
                            <#= Context.IsUseCustomDictionary ? "new OptionsetLanguageLabel" : "" #> { <#= Context.IsUseCustomDictionary ? "LanguageCode = " : "" #><#= language #>, <#= Context.IsUseCustomDictionary ? "OptionsetLabel = " : "" #>Enums.GetLabel("<#= attribute.Attribute.LogicalName #>", <#= attribute.TargetTypeForCrmSvcUtil.Contains("bool?") ? "(bool) value ? 1 : 0" : "value.Value" #>, <#= language #>) },
<#+ } #>
                        };
            }
            set
            {}
        }

<#+ } #>
<#+ } #>
<#+ } #>
		#endregion

		#region Relationships

<#+ //BEGIN// 1:N Relationships  #>
<#+	
		var relationProperties = "\t\tprotected override IDictionary<string, object[]> RelationProperties { get {\r\n\t\t\tif (relationProperties != null) return relationProperties;\r\n\t\t\trelationProperties = new Dictionary<string, object[]>();\r\n";
		var relationEnum = "\t\tpublic static class RelationNames {\r\n";
        foreach(var attribute in oneNRels)	{
			var crmEntityNameTemp =  entityFilterList.EntityFilters.First(filter => filter.IsDefault)
				.EntityFilterList.First(filter => filter.LogicalName == attribute.ToEntity.LogicalName).EntityRename
				?? (Context.UseDisplayNames ? attribute.ToEntity.FriendlyName : attribute.ToEntity.HybridName);
			var relationName = FirstNotNullOrEmpty(entityFilter.OneToNRenames, attribute.SchemaName) ?? attribute.FriendlyName;
			relationProperties += "\t\t\trelationProperties[\"" + relationName + "\"] = new object[] { " +
				"\"" + relationName + "\", " +
				"\"" + attribute.ToEntity.LogicalName + "\", " +
				"\"" + entity.LogicalName + "\", " +
				"\"" + attribute.ToField.LogicalName + "\", " +
				"\"" + entity.PrimaryKey.LogicalName + "\", " +
				"\"" + entity.PrimaryKey.LogicalName + "\", " +
				"\"" + entity.PrimaryKey.LogicalName + "\", " +
				"\"" + attribute.SchemaName + "\", " +
				"typeof (" + crmEntityNameTemp + "[])" +
				" };\r\n";
			relationEnum += "\t\t\tpublic static RelationName " + relationName + " = new RelationName(\"" +  relationName+ "\");\r\n";
#>
		
		/// <summary>
		/// 1:N, '<#= attribute.SchemaName #>'
		/// </summary>
<#+ if(attribute.SchemaName == "calendar_calendar_rules" || attribute.SchemaName == "service_calendar_rules") { #>
		[AttributeLogicalName("calendarrules")]
		public CalendarRule[] CalendarRules
		{
			get
			{
				var collection = GetAttributeValue<EntityCollection>("calendarrules");
				if (collection != null && collection.Entities != null)
					return System.Linq.Enumerable.Cast<CalendarRule>(collection.Entities).ToArray();
				else
					return null;
			}
			
			set
			{
				OnPropertyChanging("CalendarRules");
				if (RelatedEntities.IsReadOnly)
					RelatedEntities.GetType().GetProperty("IsReadOnly").SetValue(RelatedEntities, false);
    			SetAttributeValue("calendarrules", new EntityCollection(new List<Entity>(value)));
				OnPropertyChanged("CalendarRules");
			}
		}
<#+ } else { #>
		[RelationshipSchemaName("<#=attribute.SchemaName#>"<#=attribute.EntityRole=="null" ? "" :", " + attribute.EntityRole#>)<#+ if (entityFilter == null || entityFilter.OneToN == null || entityFilter.OneToN.Contains(attribute.SchemaName)) { #>, DataMember<#+ } #>]
		public <#= crmEntityNameTemp #>[] <#= relationName #>
		{
			get
			{
				var enumerable = GetRelatedEntities<<#= crmEntityNameTemp #>>("<#= attribute.SchemaName #>", <#= attribute.EntityRole #>);
				return enumerable != null ? enumerable.ToArray() : null;
			}
			set
			{
				OnPropertyChanging("<#= relationName #>");
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null)
                    value.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities<<#=crmEntityNameTemp#>>("<#= attribute.SchemaName #>", <#= attribute.EntityRole #>, value);
				OnPropertyChanged("<#= relationName #>");
			}
		}
<#+ if (Context.IsGenerateLoadPerRelation) { #>

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public <#=crmEntityNameTemp#>[] Load_<#= relationName #>(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "<#=attribute.ToEntity.LogicalName#>", LogicalName, "<#=attribute.ToField.LogicalName#>", "<#=entity.PrimaryKey.LogicalName#>", "<#=entity.PrimaryKey.LogicalName#>", "<#=entity.PrimaryKey.LogicalName#>",
					recordCountLimit, page, filter, attributes).Select(entity => entity.ToEntity<<#=crmEntityNameTemp#>>()).ToArray();
			if (result.Length <= 0) return null;
			Array.ForEach(result, entity =>
			                      {
				                      var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				                      if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
									  try { context.AttachLink(this, new Relationship("<#= attribute.SchemaName #>"), alreadyTracked); } catch { }
			                      });
			if (<#= relationName #> == null || <#= relationName #>.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public <#= crmEntityNameTemp #>[] Load_<#= relationName #>(IOrganizationService service, params string[] attributes)
		{
			return Load_<#= relationName #>(service, -1, -1, null, false, attributes);
		}

		public <#= crmEntityNameTemp #>[] Load_<#= relationName #>(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return Load_<#= relationName #>(service, -1, -1, null, isDeferred, attributes);
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the "attributes" param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public <#= crmEntityNameTemp #>[] Load_<#= relationName #>(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly)
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			<#=crmEntityNameTemp#>[] resultArray = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "<#=attribute.ToEntity.LogicalName#>", LogicalName, "<#=attribute.ToField.LogicalName#>", "<#=entity.PrimaryKey.LogicalName#>", "<#=entity.PrimaryKey.LogicalName#>", "<#=entity.PrimaryKey.LogicalName#>",
					recordCountLimit, page, filter, attributes));
			var queryAction = queryActionObject.Action =
			                  result => {
				                  var response = result as RetrieveMultipleResponse;
					              resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<<#=crmEntityNameTemp#>>()).ToArray()
	    				              : response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<<#=crmEntityNameTemp#>>()).ToArray();
				                  DeferredQueriesList.Remove(queryActionObject);
				                  if (resultArray.Length <= 0) return;
				                  if (<#= relationName #> == null) { <#= relationName #> = resultArray; return; }
				                  <#= relationName #> = <#= relationName #>.Union(resultArray).Distinct<<#= crmEntityNameTemp #>>(new EntityComparer()).ToArray();
			                  };
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
<#+ } #>
<#+ } #>
<#+ } #>
<#+
//END// 1:N Realationships

//BEGIN// N:1 Realationships 
	foreach(var attribute in nOneRels)	{
			var crmEntityNameTemp =  entityFilterList.EntityFilters.First(filter => filter.IsDefault)
				.EntityFilterList.First(filter => filter.LogicalName == attribute.ToEntity.LogicalName).EntityRename
				?? (Context.UseDisplayNames ? attribute.ToEntity.FriendlyName : attribute.ToEntity.HybridName);
			var relationName = FirstNotNullOrEmpty(entityFilter.NToOneRenames, attribute.SchemaName) ?? attribute.FriendlyName;
			relationProperties += "\t\t\trelationProperties[\"" + relationName + "\"] = new object[] { " +
				"\"" + relationName + "\", " +
				"\"" + attribute.ToEntity.LogicalName + "\", " +
				"\"" + entity.LogicalName + "\", " +
				"\"" + attribute.ToEntity.PrimaryKey.LogicalName + "\", " +
				"\"" + attribute.FromField.LogicalName + "\", " +
				"\"" + entity.PrimaryKey.LogicalName + "\", " +
				"\"" + entity.PrimaryKey.LogicalName + "\", " +
				"\"" + attribute.SchemaName + "\", " +
				"typeof (" + crmEntityNameTemp + ")" +
				" };\r\n";
			relationEnum += "\t\t\tpublic static RelationName " + relationName + " = new RelationName(\"" +  relationName+ "\");\r\n";
#>
		
		/// <summary>
		/// N:1, '<#=attribute.SchemaName#>'
		/// </summary>
		[RelationshipSchemaName("<#=attribute.SchemaName#>"<#=attribute.EntityRole=="null" ? "" :", " + attribute.EntityRole#>), AttributeLogicalName("<#=attribute.LogicalName#>")<#+ if (entityFilter == null || entityFilter.NToOne == null || entityFilter.NToOne.Contains(attribute.SchemaName)) { #>, DataMember<#+ } #>]
		public <#=crmEntityNameTemp#> <#= relationName #>
		{
			get
			{
				return GetRelatedEntity<<#= crmEntityNameTemp #>>("<#= attribute.SchemaName #>", <#= attribute.EntityRole #>);
			}
<#+ if(attribute.Property != null) { #>
			set
			{
				OnPropertyChanging("<#= relationName #>");
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null)
                    value.LogicalName = (string) value.GetType().GetField("EntityLogicalName").GetRawConstantValue();
				SetRelatedEntity<<#=crmEntityNameTemp#>>("<#=attribute.SchemaName#>", <#=attribute.EntityRole#>, value);
				OnPropertyChanged("<#= relationName #>");
			}
<#+ } #>
		}
<#+ if (attribute.Property != null) { #>
<#+ if (Context.IsGenerateLoadPerRelation) { #>

		/// <summary>
		/// Fetch the record related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public <#=crmEntityNameTemp#> Load_<#= relationName #>(IOrganizationService service, XrmServiceContext context, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            var result = GeneratorHelpers.LoadRelation(this, service, "<#=attribute.ToEntity.LogicalName#>", LogicalName, "<#=attribute.ToEntity.PrimaryKey.LogicalName#>", "<#=attribute.FromField.LogicalName#>", "<#=entity.PrimaryKey.LogicalName#>", "<#=entity.PrimaryKey.LogicalName#>",
					-1, -1, null, attributes).FirstOrDefault();
			if (result == null) { return null; }
			var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == result.Id);
			if (alreadyTracked == null) { context.Attach(result); alreadyTracked = result; }
			try { context.AttachLink(this, new Relationship("<#= attribute.SchemaName #>"), alreadyTracked); } catch { }
			if (<#= relationName #> == null || <#= relationName #>.Id != result.Id) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result.ToEntity<<#=crmEntityNameTemp#>>();
		}

		/// <summary>
		/// Fetch the records related to this entity on this relationship.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public <#=crmEntityNameTemp#> Load_<#= relationName #>(IOrganizationService service, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			<#=crmEntityNameTemp#> result = null;
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "<#=attribute.ToEntity.LogicalName#>", LogicalName, "<#=attribute.ToEntity.PrimaryKey.LogicalName#>", "<#=attribute.FromField.LogicalName#>", "<#=entity.PrimaryKey.LogicalName#>", "<#=entity.PrimaryKey.LogicalName#>",
					-1, -1, null, attributes));
			var queryAction = queryActionObject.Action =
							  resultQ => {
								  var response = resultQ as RetrieveMultipleResponse;
								  var resultTemp = response == null ? ((List<Entity>) resultQ).FirstOrDefault()
									  : response.EntityCollection.Entities.FirstOrDefault();
								  DeferredQueriesList.Remove(queryActionObject);
								  <#= relationName #> = result = (resultTemp == null ? null : resultTemp.ToEntity<<#=crmEntityNameTemp#>>());
							  };
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query));
			return result;
		}
<#+ } #>
<#+ } #>
<#+ } //END// N:1 Relationships 

//BEGIN// N:N Relationships 
	foreach(var attribute in nNRels)	{
			var crmEntityNameTemp =  entityFilterList.EntityFilters.First(filter => filter.IsDefault)
				.EntityFilterList.First(filter => filter.LogicalName == attribute.ToEntity.LogicalName).EntityRename
				?? (Context.UseDisplayNames ? attribute.ToEntity.FriendlyName : attribute.ToEntity.HybridName);
			var relationName = (FirstNotNullOrEmpty(entityFilter.NToNRenames, attribute.SchemaName) ?? attribute.FriendlyName)
				+ (nNRels.Count(r => r.SchemaName == attribute.SchemaName) > 1 ? (attribute.EntityRole == "null" ? "_1" : "_" + attribute.EntityRole.Split('.').Last()) : "");

			if (attribute.IntersectingEntity != null)
			{
				relationProperties += (attribute.EntityRole.Split('.').Last() == "Referencing")
					? "\t\t\trelationProperties[\"" + relationName + "\"] = new object[] { " +
						"\"" + relationName + "\", " +
						"\"" + entity.LogicalName + "\", " +
						"\"" + attribute.IntersectingEntity.LogicalName + "\", " +
						"\"" + entity.PrimaryKey.LogicalName + "\", " +
						"\"" + attribute.Attribute.FromKey + "\", " +
						"\"" + attribute.ToEntity.PrimaryKey.LogicalName + "\", " +
						"\"" + attribute.Attribute.ToKey + "\", " +
						"\"" + attribute.SchemaName + "\", " +
						"typeof (" + crmEntityNameTemp + "[])" +
						" };\r\n"
					: "\t\t\trelationProperties[\"" + relationName + "\"] = new object[] { " +
						"\"" + relationName + "\", " +
						"\"" + attribute.ToEntity.LogicalName + "\", " +
						"\"" + attribute.IntersectingEntity.LogicalName + "\", " +
						"\"" + attribute.ToEntity.PrimaryKey.LogicalName + "\", " +
						"\"" + attribute.Attribute.ToKey + "\", " +
						"\"" + entity.PrimaryKey.LogicalName + "\", " +
						"\"" + attribute.Attribute.FromKey + "\", " +
						"\"" + attribute.SchemaName + "\", " +
						"typeof (" + crmEntityNameTemp + "[])" +
						" };\r\n";
				relationEnum += "\t\t\tpublic static RelationName " + relationName + " = new RelationName(\"" +  relationName+ "\");\r\n";
			}
#>
		
		/// <summary>
		/// N:N, '<#=attribute.SchemaName#>'
		/// </summary>
		[RelationshipSchemaName("<#=attribute.SchemaName#>"<#=attribute.EntityRole=="null" ? "" :", " + attribute.EntityRole#>)<#+ if (entityFilter == null || entityFilter.NToN == null || entityFilter.NToN.Contains(attribute.SchemaName)) { #>, DataMember<#+ } #>]
		public <#=crmEntityNameTemp#>[] <#= relationName #>

		{
			get
			{
				var enumerable = GetRelatedEntities<<#= crmEntityNameTemp #>>("<#= attribute.SchemaName #>", <#= attribute.EntityRole #>);
				return enumerable != null ? enumerable.ToArray() : null;
			}
			set
			{
				OnPropertyChanging("<#= relationName #>");
				if (RelatedEntities.IsReadOnly) { throw new Exception("Relationship collection is read only. The context that loaded this entity must be used to create relationships."); }
                if (value != null)
                    value.ToList().ForEach(entity => entity.LogicalName = (string) value.First().GetType().GetField("EntityLogicalName").GetRawConstantValue());
				SetRelatedEntities<<#=crmEntityNameTemp#>>("<#=attribute.SchemaName#>", <#=attribute.EntityRole#>, value);
				OnPropertyChanged("<#= relationName #>");
			}
		}
<#+ if (attribute.IntersectingEntity != null && Context.Entities.Select(m => m.LogicalName).Contains(attribute.IntersectingEntity.LogicalName)) { #>
<#+ if (Context.IsGenerateLoadPerRelation) { #>

		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch.
		/// </summary>
		public <#=crmEntityNameTemp#>[] Load_<#= relationName #>(IOrganizationService service, XrmServiceContext context,
			int recordCountLimit = -1, int page = -1, FilterExpression filter = null, params string[] attributes)
		{
			if (context.MergeOption == MergeOption.NoTracking) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
<#+ if (attribute.EntityRole.Split('.').Last() == "Referencing") { #>
            var result = GeneratorHelpers.LoadRelation(this, service, "<#= entity.LogicalName #>", "<#=attribute.IntersectingEntity.LogicalName#>", "<#= entity.PrimaryKey.LogicalName #>", "<#= attribute.Attribute.FromKey #>", "<#= attribute.ToEntity.PrimaryKey.LogicalName #>", "<#= attribute.Attribute.ToKey #>", recordCountLimit, page, filter, attributes).Select(entity => entity.ToEntity<<#= crmEntityNameTemp #>>()).ToArray();
<#+ } else { #>
            var result = GeneratorHelpers.LoadRelation(this, service, "<#= attribute.ToEntity.LogicalName #>", "<#=attribute.IntersectingEntity.LogicalName#>", "<#= attribute.ToEntity.PrimaryKey.LogicalName #>", "<#= attribute.Attribute.ToKey #>", "<#=entity.PrimaryKey.LogicalName#>", "<#= attribute.Attribute.FromKey #>", recordCountLimit, page, filter, attributes).Select(entity => entity.ToEntity<<#= crmEntityNameTemp #>>()).ToArray();
<#+ } #>
			if (result.Length <= 0) return null;
			Array.ForEach(result, entity =>
			                      {
				                      var alreadyTracked = context.GetAttachedEntities().FirstOrDefault(attached => attached.Id == entity.Id);
				                      if (alreadyTracked == null) { context.Attach(entity); alreadyTracked = entity; }
									  try { context.AttachLink(this, new Relationship("<#= attribute.SchemaName #>"), alreadyTracked); } catch { }
			                      });
			if (<#= relationName #> == null || <#= relationName #>.Length != result.Length) {
				throw new Exception("Set 'MergeOption' to anything other than 'NoTracking' in the context before loading relationships.");
			}
            return result;
		}

		public <#= crmEntityNameTemp #>[] Load_<#= relationName #>(IOrganizationService service, params string[] attributes)
		{
			return Load_<#= relationName #>(service, -1, -1, null, false, attributes);
		}

		public <#= crmEntityNameTemp #>[] Load_<#= relationName #>(IOrganizationService service, bool isDeferred, params string[] attributes)
		{
			return Load_<#= relationName #>(service, -1, -1, null, isDeferred, attributes);
		}
		/// <summary>
		/// Fetch the records related to this entity on this relationship. The record limit accepts '-1', which means 'unlimited'.
		/// The page param accepts '-1', which means 'all pages'. If a page is specified, the record limit won't exceed '5000' internally.
        /// To specify columns to fetch, the attributes param accepts either "*", which means all attributes; empty, which means no attributes;
        /// or a list of column names to fetch. If 'deferred', then loading will be added to the queue to be executed later upon request.
		/// </summary>
		public <#= crmEntityNameTemp #>[] Load_<#= relationName #>(IOrganizationService service, int recordCountLimit, int page = -1,
			FilterExpression filter = null, bool isDeferred = false, params string[] attributes)
		{
			if (RelatedEntities.IsReadOnly) {
				throw new Exception("Relationship collection is ready only. The context that loaded this entity from CRM must be passed as a parameter, " +
									"or set 'MergeOption' to 'NoTracking' in the context before fetching this entity using LINQ.");
			}
			<#=crmEntityNameTemp#>[] resultArray = null;
<#+ if (attribute.EntityRole.Split('.').Last() == "Referencing") { #>
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "<#= entity.LogicalName #>", "<#= attribute.IntersectingEntity.LogicalName #>", "<#= entity.PrimaryKey.LogicalName #>", "<#= attribute.Attribute.FromKey #>", "<#= attribute.ToEntity.PrimaryKey.LogicalName #>", "<#= attribute.Attribute.ToKey #>", recordCountLimit, page, filter, attributes));
<#+ } else { #>
			var queryActionObject = new QueryAction(GeneratorHelpers.GetLoadRelationQuery(this, service, "<#= attribute.ToEntity.LogicalName #>", "<#= attribute.IntersectingEntity.LogicalName #>", "<#= attribute.ToEntity.PrimaryKey.LogicalName #>", "<#= attribute.Attribute.ToKey #>", "<#=entity.PrimaryKey.LogicalName#>", "<#= attribute.Attribute.FromKey #>", recordCountLimit, page, filter, attributes));
<#+ } #>
			var queryAction = queryActionObject.Action =
			                  result => {
				                  var response = result as RetrieveMultipleResponse;
					              resultArray = response == null ? resultArray = ((List<Entity>) result).Select(entityQ => entityQ.ToEntity<<#=crmEntityNameTemp#>>()).ToArray()
	    				              : response.EntityCollection.Entities.Select(entityQ => entityQ.ToEntity<<#=crmEntityNameTemp#>>()).ToArray();
				                  DeferredQueriesList.Remove(queryActionObject);
				                  if (resultArray.Length <= 0) return;
				                  if (<#= relationName #> == null) { <#= relationName #> = resultArray; return; }
				                  <#= relationName #> = <#= relationName #>.Union(resultArray).Distinct<<#= crmEntityNameTemp #>>(new EntityComparer()).ToArray();
			                  };
			if (isDeferred) DeferredQueriesList.Add(queryActionObject);
			else queryAction.Invoke(GeneratorHelpers.LoadRelation(service, queryActionObject.Query, recordCountLimit, page));
			return resultArray;
		}
<#+ } #>
<#+ } #>
<#+ //END// N:N Realationships  #>
<#+ }
	relationProperties += "\t\t\treturn relationProperties; } }\r\n";
	relationEnum += "\t\t}\r\n";
#>
		
<#= relationEnum #>

<#= relationProperties #>

		#endregion

		/// <summary>
		/// Constructor for populating via LINQ queries given a LINQ anonymous type
		/// <param name="anonymousType">LINQ anonymous type.</param>
		/// </summary>
		public <#= crmEntityName #>(object anonymousType) : 
				this()
		{
            foreach (var p in anonymousType.GetType().GetProperties())
            {
                var value = p.GetValue(anonymousType, null);
                if (p.PropertyType == typeof(System.Guid))
                {
                    // Type is Guid, must be Id
                    base.Id = (System.Guid)value;
<#+ if(entity.PrimaryKey.IsValidForCreate) { #>
                    Attributes["<#=entity.PrimaryKey.LogicalName#>"] = base.Id;
<#+ } #>
               }
                else if (p.Name == "FormattedValues")
                {
                    // Add Support for FormattedValues
                    FormattedValues.AddRange((FormattedValueCollection)value);
                }
                else
                {
                    Attributes[p.Name.ToLower()] = value;
                }
            }
		}

<#+ } #>

<#+ if (Context.JsEarlyBoundEntities.Contains(entity.LogicalName) || Context.PluginMetadataEntities.Contains(entity.LogicalName)) { #>

		#region Label/value pairs

<#+ foreach(var enm in entity.Enums) {
        var attribute = entity.Fields.FirstOrDefault(field => field.LogicalName == enm.LogicalName);
        var attributeName = Context.UseDisplayNames ? (FirstNotNullOrEmpty(entityFilter.AttributeRenames, attribute == null ? "" : attribute.Attribute.LogicalName) ?? enm.FriendlyName) : enm.DisplayName;
 #>
		#region <#= attributeName #>

		public enum <#= attributeName #>Enum
		{
<#+ foreach(var item in enm.Items) { #>
			[EnumMember]<#= item.Name #> = <#= item.Value #>,
<#+ } #>
		}

		#endregion
	
<#+ } #>
		#endregion

<#+ } #>

		#region Metadata

<#+ if ((Context.OptionsetLabelsEntities != null && Context.OptionsetLabelsEntities.Contains(entity.LogicalName)) || Context.PluginMetadataEntities.Contains(entity.LogicalName)) { #>

		#region Enums

		public static class Enums
		{
			/// <summary>
			/// Gets the label corresponding to the option-set's value using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="constant">The value from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns></returns>
			public static string GetLabel(string logicalName, int constant, int languageCode = 1033)
			{
				return GeneratorHelpers.GetLabel(logicalName, constant, typeof(Enums), languageCode);
			}
			/// <summary>
			/// Gets the value corresponding to the option-set's label using its logical name,
			/// the value within, and the language code.
			/// </summary>
			/// <param name="logicalName">The logical name of the option-set in CRM</param>
			/// <param name="label">The label from the option-set</param>
			/// <param name="languageCode">The language code from CRM</param>
			/// <returns>The value corresponding to the label</returns>
			public static int GetValue(string logicalName, string label, int languageCode = 1033)
			{
				return GeneratorHelpers.GetValue(logicalName, label, typeof(Enums), languageCode);
			}

			#region Logical names

			public static class Names
			{
<#+ foreach(var enm in entity.Enums) {
        var attribute = entity.Fields.FirstOrDefault(field => field.LogicalName == enm.LogicalName);
        var attributeName = Context.UseDisplayNames ? (FirstNotNullOrEmpty(entityFilter.AttributeRenames, attribute == null ? "" : attribute.Attribute.LogicalName) ?? enm.FriendlyName) : enm.DisplayName;
#>
				public const string <#= attributeName #> = "<#= enm.LogicalName #>";
<#+ } #>
			}

			#endregion

			#region Labels

			public static class Labels
			{
<#+foreach(var enm in entity.Enums) {
        var attribute = entity.Fields.FirstOrDefault(field => field.LogicalName == enm.LogicalName);
        var attributeName = Context.UseDisplayNames ? (FirstNotNullOrEmpty(entityFilter.AttributeRenames, attribute == null ? "" : attribute.Attribute.LogicalName) ?? enm.FriendlyName) : enm.DisplayName;
#>
				public static class <#= attributeName #> 
				{
<#+foreach(var item in enm.Items){#>
<#+foreach(var itemLoc in item.LocalizedLabels){#>
					public const string <#= item.Name #>_<#= itemLoc.LanguageCode #> = <#= ToLiteral(itemLoc.Label) #>;
<#+}#>
<#+}#>

					public static int GetValue(string label, int languageCode = 1033)
					{
						return GeneratorHelpers.GetValue(typeof(<#= attributeName #>), label, languageCode);
					}
				}

<#+ } #>
			}

			#endregion
		}

		#endregion
<#+ } #>

<#+ if (Context.PluginMetadataEntities.Contains(entity.LogicalName)) { #>

		#region Fields

		public static class Fields
		{
			#region Logical names

<#+foreach(var f in entity.Fields.Where(fieldQ => !fieldQ.Attribute.IsEntityReferenceHelper && fieldQ.IsValidForRead)) {#>
			public const string <#= Context.UseDisplayNames ? (FirstNotNullOrEmpty(entityFilter.AttributeRenames, f.Attribute.LogicalName) ?? f.FriendlyName) : f.DisplayName #> = "<#=f.Attribute.LogicalName#>";
<#+}#>

			#endregion

			#region Schema names

			public static class Schema
			{
<#+foreach(var f in entity.Fields.Where(fieldQ => !fieldQ.Attribute.IsEntityReferenceHelper && fieldQ.IsValidForRead)) {#>
				public const string <#= Context.UseDisplayNames ? (FirstNotNullOrEmpty(entityFilter.AttributeRenames, f.Attribute.LogicalName) ?? f.FriendlyName) : f.DisplayName #> = "<#=f.SchemaName#>";
<#+}#>
			}

			#endregion

			#region Labels

			public static class Labels
			{
<#+ foreach(var f in entity.Fields.Where(fieldQ => !fieldQ.Attribute.IsEntityReferenceHelper && fieldQ.IsValidForRead)) {#>
<#+ if (f.LocalizedLabels != null) { #>
				public static class <#= Context.UseDisplayNames ? (FirstNotNullOrEmpty(entityFilter.AttributeRenames, f.Attribute.LogicalName) ?? f.FriendlyName) : f.DisplayName #>
				{
<#+ foreach(var fLoc in f.LocalizedLabels) { #>
					public const string _<#= fLoc.LanguageCode #> = <#= ToLiteral(fLoc.Label) #>;
<#+ } #>
				}

<#+ } #>
<#+ } #>
			}

			#endregion
		}

		#endregion

		#region Relations

		public static class Relations
		{
			public static class OneToN
			{
<#+ //BEGIN// 1:N Realationships
	foreach(var attribute in oneNRels)	{#>
<#+ if(attribute.SchemaName == "calendar_calendar_rules" || attribute.SchemaName == "service_calendar_rules") { #>
				public const string <#=attribute.SchemaName#> = "calendarrules";
<#+ } else {
			var relationName = FirstNotNullOrEmpty(entityFilter.OneToNRenames, attribute.SchemaName) ?? attribute.FriendlyName;
#>
				public const string <#=relationName#> = "<#=attribute.SchemaName#>";
<#+ } #>
<#+ } #>
			}
<#+ //END// 1:N Realationships #>
			
			public static class NToOne
			{
<#+ //BEGIN// N:1 Relationships 
	foreach(var attribute in nOneRels)	{
			var relationName = FirstNotNullOrEmpty(entityFilter.NToOneRenames, attribute.SchemaName) ?? attribute.FriendlyName;
#>
				public const string <#= relationName #> = "<#=attribute.SchemaName#>";
<#+ } #>

				public static class Lookups
				{
<#+ //BEGIN// N:1 Relationships lookups
	foreach(var attribute in nOneRels)	{
			var relationName = FirstNotNullOrEmpty(entityFilter.NToOneRenames, attribute.SchemaName) ?? attribute.FriendlyName;
#>
					public const string <#=relationName#> = "<#=attribute.LogicalName#>";
<#+ } #>
				}
			}
<#+ //END// N:1 Realationships #>

			public static class NToN
			{

<#+ //BEGIN// N:N Realationships 
	foreach(var attribute in nNRels.GroupBy(element => element.SchemaName).Select(group => group.First()))	{
			var relationName = FirstNotNullOrEmpty(entityFilter.NToNRenames, attribute.SchemaName) ?? attribute.FriendlyName;
#>
				public const string <#= relationName #> = "<#= attribute.SchemaName #>";
<#+ } #>
			}
<#+ //END// N:N Relationships  #>
		}

		#endregion
<#+ } #>

		#endregion
	}
<#+ foreach (var entityFilterT in entityFilterList.EntityFilters) { 
			var prefix = entityFilterT.Prefix;
			var suffix = entityFilterT.Suffix;
			var entityFilterQ = entityFilterT.EntityFilterList.First(filter => filter.LogicalName == entity.LogicalName);

			if (entityFilterQ.IsExcluded)
			{
				continue;
			}

			var contractEntityName =  entityFilterQ.EntityRename ?? crmEntityName;
#>

<#+ //START// Contracts  #>

	#region <#= prefix + contractEntityName + suffix #> contract

	[DataContract, CrmEntityMapping("<#= entity.LogicalName #>", "<#= entity.SchemaName #>", <#= ToLiteral(entity.Label) #>)]
	public partial class <#= prefix + contractEntityName + suffix #> : EntityContract
	{
<#+ if (entityFilterQ.ValueClearMode != null) { #>
		[DataMember] public override ClearMode? ValueClearMode { get { return ClearMode.<#= entityFilterQ.ValueClearMode #>; } set{} }
<#+ } #>
		[DataMember, CrmFieldMapping("<#= entity.PrimaryKey.LogicalName #>")] public Guid? Id;
<#+	foreach(var attribute in entity.Fields.Where(fieldQ => !fieldQ.Attribute.IsEntityReferenceHelper && fieldQ.IsValidForRead && entityFilterQ.Attributes.Contains(fieldQ.Attribute.LogicalName)))	{
            var attributeName = Context.UseDisplayNames ? (FirstNotNullOrEmpty(entityFilterQ.AttributeRenames, attribute.Attribute.LogicalName) ?? attribute.FriendlyName) : attribute.DisplayName;

            string attributeType = null;

            if (attribute.TargetTypeForCrmSvcUtil.Contains("EntityReference") && string.IsNullOrEmpty(attribute.LookupSingleType))
            {
                attributeType = "EntityReference";
            }
            else if (attribute.TargetTypeForCrmSvcUtil.Contains("OptionSetValue") || attribute.IsStateCode)
            {
               attributeType = crmEntityName + "." + attributeName + "Enum?";
            }
            else
            {
                attributeType = ConvertToContractType(attribute);
            }
#>
		[DataMember<#= (entityFilterQ.ReadOnly != null && entityFilterQ.ReadOnly.Contains(attribute.LogicalName)) ? ", ReadOnlyField" : "" #>, CrmFieldMapping("<#=attribute.Attribute.LogicalName#>"<#+ if (attribute.TargetTypeForCrmSvcUtil.Contains("EntityReference") && !attributeType.Contains("EntityReference")) { #>, "<#= attribute.LookupSingleType #>"<#+ } #>)<#+ /* if (attribute.IsRequired) { #>, Required<#+ } #><#+ if (attribute.MaxLength != null) { #>, MaxLength(<#= attribute.MaxLength #>)<#+ } #><#+ if (attribute.Min != null && attribute.Max != null) { #>, InRange("<#= attribute.Min #>", "<#= attribute.Max #>", typeof(<#= attributeType.Replace("?","") #>))<#+ } */ #>] public <#= attributeType #> <#= attributeName #>;
<#+ if (entityFilterQ.ClearFlag != null && entityFilterQ.ClearFlag.Contains(attribute.LogicalName)) { #>
		[DataMember] public bool Clear_<#= attributeName #> = false;
<#+ } #>
<#+ if (attribute.TargetTypeForCrmSvcUtil.Contains("EntityReference")) { #>
        [DataMember] public string <#= attributeName #>Name;
<#+ if (entityFilterQ.IsLookupLabels) { #>
        [DataMember<#+ if (attribute.LookupLabel != null && !string.IsNullOrEmpty(attribute.LookupLabel.LabelFieldNames)) { #>, Label("<#= attribute.LookupLabel.LabelFieldNames #>", "<#= attribute.LookupLabel.LogicalName #>", "<#= attribute.LookupLabel.IdFieldName #>", "<#=attribute.Attribute.LogicalName#>")<#+ } #>] public <#= Context.IsUseCustomDictionary ? "List<OptionsetLanguageLabel>" : "IDictionary<int, string>" #> <#= attributeName #>Labels { get; set; }
<#+ } #>
<#+ } #>
<#+ if (entityFilterQ.IsOptionsetLabels && (attribute.TargetTypeForCrmSvcUtil.Contains("OptionSetValue") || attribute.TargetTypeForCrmSvcUtil.Contains("bool?") || attribute.IsStateCode) && entity.Enums.Any()) { #>
<#+     var enm = entity.Enums.FirstOrDefault(field => field.LogicalName == attribute.LogicalName);
		if (enm != null && enm.Items.Any())	{
 #>
        [DataMember] public <#= Context.IsUseCustomDictionary ? "List<OptionsetLanguageLabel>" : "IDictionary<int, string>" #> <#= attributeName #>Labels { get; set; }
<#+ } #>
<#+ } #>
<#+ } #>

		#region Relationships

<#+ //BEGIN// 1:N Realationships
        var oneNRelsContract = entity.RelationshipsOneToMany.Where(r => Context.Entities.Select(m => m.LogicalName).Contains(r.Type)
			&& entityFilterT.EntityFilterList.Any(filter => filter.LogicalName == r.Type)
			&& entityFilterQ.OneToN.Contains(r.SchemaName));
        foreach(var attribute in oneNRelsContract)	{
			var crmEntityNameTemp =  entityFilterList.EntityFilters.First(filter => filter.IsDefault)
				.EntityFilterList.First(filter => filter.LogicalName == attribute.ToEntity.LogicalName).EntityRename
				?? (Context.UseDisplayNames ? attribute.ToEntity.FriendlyName : attribute.ToEntity.HybridName);
			var contractEntityNameTemp =  entityFilterT.EntityFilterList.First(filter => filter.LogicalName == attribute.ToEntity.LogicalName).EntityRename
				?? (Context.UseDisplayNames ? attribute.ToEntity.FriendlyName : attribute.ToEntity.HybridName);
			var relationName = FirstNotNullOrEmpty(entityFilterQ.OneToNRenames, attribute.SchemaName) ?? attribute.FriendlyName;
			var isReadOnly = FirstNotNullOrDefault(entityFilterQ.OneToNReadOnly, attribute.SchemaName);
#>
<#+ if(attribute.SchemaName == "calendar_calendar_rules" || attribute.SchemaName == "service_calendar_rules") { #>
		[AttributeLogicalName("calendarrules")] public CalendarRule[] CalendarRules;
<#+ } else { #>
		[DataMember<#= isReadOnly ? ", ReadOnlyField" : "" #>, CrmRelationMapping("<#=attribute.SchemaName#>", typeof(<#= crmEntityNameTemp #>)<#=attribute.EntityRole == "null" ? "" :", " + attribute.EntityRole#>)] public <#= prefix + contractEntityNameTemp + suffix #>[] <#= relationName #>;
<#+ } #>
<#+ } //END// 1:N Realationships #>

<#+ //BEGIN// N:1 Realationships 
    var nOneRelsContract = entity.RelationshipsManyToOne.Where(r => Context.Entities.Select(m => m.LogicalName).Contains(r.Type)
			&& entityFilterT.EntityFilterList.Any(filter => filter.LogicalName == r.Type)
			&& entityFilterQ.NToOne.Contains(r.SchemaName));

	foreach(var attributeR in nOneRelsContract)	{
			var crmEntityNameTemp =  entityFilterList.EntityFilters.First(filter => filter.IsDefault)
				.EntityFilterList.First(filter => filter.LogicalName == attributeR.ToEntity.LogicalName).EntityRename
				?? (Context.UseDisplayNames ? attributeR.ToEntity.FriendlyName : attributeR.ToEntity.HybridName);
			var contractEntityNameTemp =  entityFilterT.EntityFilterList.First(filter => filter.LogicalName == attributeR.ToEntity.LogicalName).EntityRename
				?? (Context.UseDisplayNames ? attributeR.ToEntity.FriendlyName : attributeR.ToEntity.HybridName);
			var relationName = FirstNotNullOrEmpty(entityFilterQ.NToOneRenames, attributeR.SchemaName) ?? attributeR.FriendlyName;
			var flatten = entityFilterQ.NToOneFlatten == null || (entityFilterQ.NToOneFlatten.ContainsKey(attributeR.SchemaName) && entityFilterQ.NToOneFlatten[attributeR.SchemaName]);
			var isReadOnly = FirstNotNullOrDefault(entityFilterQ.NToOneReadOnly, attributeR.SchemaName);
#>
		[<#= flatten ? "" : "DataMember, " #>CrmRelationMapping("<#=attributeR.SchemaName#>", typeof(<#= crmEntityNameTemp #>)<#=attributeR.EntityRole == "null" ? "" :", " + attributeR.EntityRole#>)<#= isReadOnly ? ", ReadOnlyField" : "" #>] public <#= prefix + contractEntityNameTemp + suffix #> <#= relationName #>;
<#+	var entityFilterQF = entityFilterT.EntityFilterList.First(filter => filter.LogicalName == attributeR.ToEntity.LogicalName);
	if (flatten)
	{
#>

		#region <#= relationName #> Flat Structure

<#+
		foreach(var attribute in attributeR.ToEntity.Fields.Where(fieldQ => (!fieldQ.Attribute.IsEntityReferenceHelper && fieldQ.IsValidForRead && entityFilterQF.Attributes.Contains(fieldQ.Attribute.LogicalName)) || fieldQ.Attribute.LogicalName == attributeR.ToEntity.PrimaryKey.LogicalName))	{
				var attributeName = (attribute.Attribute.LogicalName == attributeR.ToEntity.PrimaryKey.LogicalName)
					? "Id"
					: (Context.UseDisplayNames ? (FirstNotNullOrEmpty(entityFilterQF.AttributeRenames, attribute.Attribute.LogicalName) ?? attribute.FriendlyName) : attribute.DisplayName);

				string attributeType = null;

				if (attribute.TargetTypeForCrmSvcUtil.Contains("EntityReference") && string.IsNullOrEmpty(attribute.LookupSingleType))
				{
					attributeType = "EntityReference";
				}
				else if (attribute.TargetTypeForCrmSvcUtil.Contains("OptionSetValue") || attribute.IsStateCode)
				{
				   attributeType = crmEntityNameTemp + "." + attributeName + "Enum?";
				}
				else
				{
					attributeType = ConvertToContractType(attribute);
				}
#>
		[DataMember<#= (entityFilterQ.ReadOnly != null && entityFilterQ.ReadOnly.Contains(attribute.LogicalName)) || isReadOnly ? ", ReadOnlyField" : "" #>, CrmFieldMapping("<#=attribute.Attribute.LogicalName#>"<#+ if (attribute.TargetTypeForCrmSvcUtil.Contains("EntityReference") && !attributeType.Contains("EntityReference")) { #>, "<#= attribute.LookupSingleType #>"<#+ } #>), CrmRelationMapping("<#=attributeR.SchemaName#>", typeof(<#= crmEntityNameTemp #>)<#=attributeR.EntityRole == "null" ? "" :", " + attributeR.EntityRole#>)] public <#= attributeType #> <#= relationName #>_<#= attributeName #>;
<#+ if (attribute.TargetTypeForCrmSvcUtil.Contains("EntityReference")) { #>
        [DataMember] public string <#= relationName #>_<#= attributeName #>Name;
<#+ if (entityFilterQF.IsLookupLabels) { #>
        [DataMember<#+ if (attribute.LookupLabel != null && !string.IsNullOrEmpty(attribute.LookupLabel.LabelFieldNames)) { #>, Label("<#= attribute.LookupLabel.LabelFieldNames #>", "<#= attribute.LookupLabel.LogicalName #>", "<#= attribute.LookupLabel.IdFieldName #>", "<#=attribute.Attribute.LogicalName#>")<#+ } #>] public <#= Context.IsUseCustomDictionary ? "List<OptionsetLanguageLabel>" : "IDictionary<int, string>" #> <#= relationName #>_<#= attributeName #>Labels { get; set; }
<#+ } #>
<#+ } #>
<#+ if (entityFilterQF.IsOptionsetLabels && (attribute.TargetTypeForCrmSvcUtil.Contains("OptionSetValue") || attribute.IsStateCode) && attributeR.ToEntity.Enums.Any()) { #>
<#+     var enm = attributeR.ToEntity.Enums.FirstOrDefault(field => field.LogicalName == attribute.LogicalName);
		if (enm != null && enm.Items.Any())
		{
			var languages = enm.Items.First().LocalizedLabels.Select(label => label.LanguageCode);
#>
        [DataMember]
        public <#= Context.IsUseCustomDictionary ? "List<OptionsetLanguageLabel>" : "IDictionary<int, string>" #> <#= relationName #>_<#= attributeName #>Labels
        {
		    get
		    {
                if (<#= relationName #>_<#= attributeName #> == null)
                    return null;
                return <#= Context.IsUseCustomDictionary ? "new List<OptionsetLanguageLabel>" : "new Dictionary<int, string>" #>
                        {
<#+ foreach(var language in languages) { #>
                            <#= Context.IsUseCustomDictionary ? "new OptionsetLanguageLabel" : "" #> { <#= Context.IsUseCustomDictionary ? "LanguageCode = " : "" #><#= language #>, <#= Context.IsUseCustomDictionary ? "OptionsetLabel = " : "" #><#= crmEntityNameTemp #>.Enums.GetLabel("<#=attribute.Attribute.LogicalName#>", (int) <#= relationName #>_<#= attributeName #>, <#= language #>) },
<#+ } #>
                        };
            }
            set
            {}
        }
<#+ } #>
<#+ } #>
<#+ } #>

		#endregion
<#+ } #>
<#+ } //END// N:1 Realationships  #>

<#+ //BEGIN// N:N Realationships
    var nNRelsContract = entity.RelationshipsManyToMany.Where(r => Context.Entities.Select(m => m.LogicalName).Contains(r.Type)
			&& entityFilterT.EntityFilterList.Any(filter => filter.LogicalName == r.Type)
			&& entityFilterQ.NToN.Contains(r.SchemaName));

	foreach(var attribute in nNRelsContract)	{
			var crmEntityNameTemp =  entityFilterList.EntityFilters.First(filter => filter.IsDefault)
				.EntityFilterList.First(filter => filter.LogicalName == attribute.ToEntity.LogicalName).EntityRename
				?? (Context.UseDisplayNames ? attribute.ToEntity.FriendlyName : attribute.ToEntity.HybridName);
			var contractEntityNameTemp =  entityFilterT.EntityFilterList.First(filter => filter.LogicalName == attribute.ToEntity.LogicalName).EntityRename
				?? (Context.UseDisplayNames ? attribute.ToEntity.FriendlyName : attribute.ToEntity.HybridName);
			var relationName = (FirstNotNullOrEmpty(entityFilterQ.NToNRenames, attribute.SchemaName) ?? attribute.FriendlyName)
				+ (nNRelsContract.Count(r => r.SchemaName == attribute.SchemaName) > 1 ? (attribute.EntityRole == "null" ? "_1" : "_" + attribute.EntityRole.Split('.').Last()) : "");
			var isReadOnly = FirstNotNullOrDefault(entityFilterQ.NToNReadOnly, attribute.SchemaName);
#>
		[DataMember<#= isReadOnly ? ", ReadOnlyField" : "" #>, CrmRelationMapping("<#=attribute.SchemaName#>", typeof(<#= crmEntityNameTemp #>)<#=attribute.EntityRole == "null" ? "" :", " + attribute.EntityRole#>)] public <#= prefix + contractEntityNameTemp + suffix #>[] <#= relationName #>;
<#+ } //END// N:N Realationships  #>

		#endregion
	}

	#endregion
<#+ } #>
<#+ foreach (var entityFilterT in entityFilterList.EntityFilters) { 
			var prefix = entityFilterT.Prefix;
			var suffix = entityFilterT.Suffix;
			var entityFilterQ = entityFilterT.EntityFilterList.First(filter => filter.LogicalName == entity.LogicalName);

			if (!entityFilterQ.IsGenerateMeta)
			{
				continue;
			}
#>

	#region <#= prefix + crmEntityName + suffix #> labels

    [DataContract]
    public class <#= prefix + crmEntityName + suffix #>Labels
    {
        [DataMember] public string EntityLabel = "<#= entity.Label ?? "NO_LABEL" #>";

		#region Attributes keyed labels

<#+ foreach(var f in entity.Fields.Where(fieldQ => !fieldQ.Attribute.IsEntityReferenceHelper && fieldQ.IsValidForRead
        && entityFilterQ.Attributes.Contains(fieldQ.Attribute.LogicalName))) {
#>
<#+ if (f.LocalizedLabels != null && f.LocalizedLabels.Any()) {
        var fieldName = Context.UseDisplayNames ? (FirstNotNullOrEmpty(entityFilterQ.AttributeRenames, f.Attribute.LogicalName) ?? f.FriendlyName) : f.DisplayName;
#>
        [DataMember]
        public <#= Context.IsUseCustomDictionary ? "List<OptionsetLanguageLabel>" : "IDictionary<int, string>" #> <#= fieldName #>
        {
            get
            {
                 return <#= Context.IsUseCustomDictionary ? "new List<OptionsetLanguageLabel>" : "new Dictionary<int, string>" #>
                        {
<#+ foreach(var fLoc in f.LocalizedLabels) { #>
                            <#= Context.IsUseCustomDictionary ? "new OptionsetLanguageLabel" : "" #> { <#= Context.IsUseCustomDictionary ? "LanguageCode = " : "" #><#= fLoc.LanguageCode #>, <#= Context.IsUseCustomDictionary ? "OptionsetLabel = " : "" #><#= ToLiteral(fLoc.Label) #> },
<#+ } #>
                        };
            }
            set {}
        }
<#+ } #>
<#+ } #>
 
		#endregion

		#region Enums keyed labels

<#+ foreach(var enm in entity.Enums) {
        var attribute = entity.Fields.FirstOrDefault(field => field.LogicalName == enm.LogicalName);
        if (!enm.Items.Any() || !entityFilterQ.Attributes.Contains(attribute.Attribute.LogicalName))
            continue;
        var attributeName = Context.UseDisplayNames ? (FirstNotNullOrEmpty(entityFilterQ.AttributeRenames, attribute == null ? "" : attribute.Attribute.LogicalName) ?? enm.FriendlyName) : enm.DisplayName;
        var languagesCreated = new List<int>();
#>
        [DataMember]
        public IDictionary<int, IDictionary<string, int>> <#= attributeName #>Enum
        {
            get
            {
                var languages = new Dictionary<int, IDictionary<string, int>>();
<#+ foreach(var item in enm.Items) { #>
<#+ foreach(var itemLoc in item.LocalizedLabels) {
        if (!languagesCreated.Contains(itemLoc.LanguageCode))
        {
            languagesCreated.Add(itemLoc.LanguageCode);
#>
                languages[<#= itemLoc.LanguageCode #>] = new Dictionary<string, int>();
<#+ } #>
                languages[<#= itemLoc.LanguageCode #>].Add(<#= ToLiteral(itemLoc.Label) #>, <#= item.Value #>);
<#+ } #>
<#+ } #>
                return languages;
            }
            set {}
        }

<#+ } #>

		#endregion
    }

	#endregion
<#+ } #>
<#+ //END// Contracts  #>

	#endregion
<#+
		manager.EndBlock(); 
	}

	void Generate(Manager manager)
	{
		foreach (var entity in Context.Entities)
		{
			Generate(manager, entity);
		}

		manager.StartFooter();
#>

	#endregion

}

<#+
		manager.EndBlock();

		manager.Process(Context.SplitFiles);
	}
#>
<#+
	private void ParseActions(MappingAction[] actions)
	{
#>
<#+ foreach(var action in actions.GroupBy(action => action.VarName).Select(group => group.First())) { #>
<#+ if(!string.IsNullOrEmpty(action.Description)) { #>
			/// <summary>
			/// <#=action.Description.Replace("\n","").Replace("\r", " \r\n\t\t/// ") #>
			/// </summary>
<#+ } #>
			public class <#=action.VarName#>
			{
				public IOrganizationService Service;
				public OrganizationRequest Request;
				public OrganizationResponse Response;
				public Inputs InputParams;
				public Outputs OutputFields;
				
				public <#=action.VarName#>()
				{
					Request = new OrganizationRequest("<#=action.Name#>");
					InputParams = new Inputs(Request);
				}
				
				public <#=action.VarName#>(IOrganizationService service) : this()
				{
					Service = service;
				}
				
<#+
		if (action.InputFields.Any(field => !field.Optional))
		{
#>
				public <#=action.VarName#>(
<#+
	var addComma = false;
	for(var i = 0; i < action.InputFields.Length; i++)
	{
		var inputField = action.InputFields[i];

		if (!inputField.Optional)
		{
			var typeString = (inputField.VarName == "Target") ? "Guid" : inputField.TypeName;
#>					<#+ if(addComma){ #>, <#+ } addComma = true; #><#= typeString #> <#= inputField.VarName #>
<#+ } #>
<#+ } if(addComma){ #>					, <#+ } #>IOrganizationService service = null) : this()
				{
					Service = service;
<#+
	for(var i = 0; i < action.InputFields.Length; i++)
	{
		var inputField = action.InputFields[i];

		if (!inputField.Optional)
		{
#>
					InputParams.<#=inputField.VarName#> = <#=inputField.VarName#>;
<#+}#>
<#+}#>
				}
<#+}#>

				public Outputs Execute(IOrganizationService service = null)
				{
					if (service != null)
					{
						Service = service;
					}

					Response = Service.Execute(Request);

					return OutputFields = new Outputs(Response);
				}
				
				public class Inputs
				{
					public OrganizationRequest Request;

					public Inputs(OrganizationRequest request)
					{
						Request = request;
					}

<#+ foreach(var inputField in action.InputFields) {
		var typeString = (inputField.VarName == "Target") ? "Guid" : inputField.TypeName;
#>
<#+ if(inputField.Optional) { #>
					/// <summary>
					///		OPTIONAL!
					/// </summary>
<#+ } #>
					public <#= typeString #> <#= inputField.VarName #>
					{
						set
						{
<#+ if (inputField.VarName == "Target") { #>
							Request["<#=inputField.Name#>"] = new EntityReference("<#= action.TargetEntityName #>", value);
<#+ } else { #>
							Request["<#=inputField.Name#>"] = value;
<#+ } #>
						}
						get
						{
<#+ if (inputField.VarName == "Target") { #>
							return ((EntityReference) Request["<#=inputField.Name#>"]).Id;
<#+ } else { #>
							return (<#= typeString #>) Request["<#=inputField.Name#>"];
<#+ } #>
						}
					}
<#+ } #>
				}
				
				public class Outputs
				{
					public OrganizationResponse Response;

					public Outputs(OrganizationResponse response)
					{
						Response = response;
					}

<#+ foreach(var outputField in action.OutputFields) { #>
					public <#= outputField.TypeName #> <#= outputField.VarName #>
					{
							private set {}
							get
						{
							return (<#= outputField.TypeName #>) Response["<#=outputField.Name#>"];
						}
					}
<#+ } #>
				}
			}
<#+ } #>
<#+ } #>
<#+
    // Credit :http://stackoverflow.com/questions/323640/can-i-convert-a-c-sharp-string-value-to-an-escaped-string-literal
    private static string ToLiteral(string input)
    {
        using (var writer = new StringWriter())
        {
            using (var provider = CodeDomProvider.CreateProvider("CSharp"))
            {
                provider.GenerateCodeFromExpression(new CodePrimitiveExpression(input), writer, null);
                return writer.ToString();
            }
        }
    }

	private static string ConvertToContractType(MappingField field)
	{
		var crmType = field.TargetTypeForCrmSvcUtil;

		if (crmType.Contains("OptionSetValue") || field.IsStateCode)
		{
			return field.DisplayName + "Enum?";
		}
		else if (crmType.Contains("EntityReference"))
		{
			return "Guid?";
		}
		else if (crmType.Contains("Money"))
		{
			return "decimal?";
		}
		else
		{
			return crmType;
		}
	}

    private static TValue FirstNotNullOrDefault<TKey, TValue>(IDictionary<TKey, TValue> dictionary, params TKey[] keys)
    {
      return Enumerable.FirstOrDefault<TValue>(Enumerable.Select<TKey, TValue>(Enumerable.Where<TKey>((IEnumerable<TKey>) keys, new Func<TKey, bool>(dictionary.ContainsKey)), (Func<TKey, TValue>) (key => dictionary[key])));
    }

    private static string FirstNotNullOrEmpty<TKey>(IDictionary<TKey, string> dictionary, params TKey[] keys)
    {
        return Enumerable.FirstOrDefault<string>(Enumerable.Select<TKey, string>(Enumerable.Where<TKey>((IEnumerable<TKey>)keys, (Func<TKey, bool>)(key =>
        {
            if (dictionary.ContainsKey(key))
                return !string.IsNullOrEmpty(dictionary[key]);
            return false;
        })), (Func<TKey, string>)(key => dictionary[key])));
    }

	// Credit: https://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
	// Manager class records the various blocks so it can split them up
	class Manager {
		private class Block {
			public String Name;
			public int Start, Length;
		}

		private Block currentBlock;
		private List<Block> files = new List<Block>();
		private Block footer = new Block();
		private Block header = new Block();
		private ITextTemplatingEngineHost host;
		private StringBuilder template;
		protected List<String> generatedFileNames = new List<String>();

		public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template) {
			return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
		}

		public void StartNewFile(String name) {
			if (name == null)
				throw new ArgumentNullException("name");
			CurrentBlock = new Block { Name = name };
		}

		public void StartFooter() {
			CurrentBlock = footer;
		}

		public void StartHeader() {
			CurrentBlock = header;
		}

		public void EndBlock() {
			if (CurrentBlock == null)
				return;
			CurrentBlock.Length = template.Length - CurrentBlock.Start;
			if (CurrentBlock != header && CurrentBlock != footer)
				files.Add(CurrentBlock);
			currentBlock = null;
		}

		public virtual void Process(bool split) {
			if (split) {
				EndBlock();
				String headerText = template.ToString(header.Start, header.Length);
				String footerText = template.ToString(footer.Start, footer.Length);
				String outputPath = Path.GetDirectoryName(host.TemplateFile);
				files.Reverse();
				foreach(Block block in files) {
					String fileName = Path.Combine(outputPath, block.Name);
					String content = headerText + template.ToString(block.Start, block.Length) + footerText;
					generatedFileNames.Add(fileName);
					CreateFile(fileName, content);
					template.Remove(block.Start, block.Length);
				}
			}
		}

		protected virtual void CreateFile(String fileName, String content) {
			if (IsFileContentDifferent(fileName, content))
				File.WriteAllText(fileName, content);
		}

		public virtual String GetCustomToolNamespace(String fileName) {
			return null;
		}

		public virtual String DefaultProjectNamespace {
			get { return null; }
		}

		protected bool IsFileContentDifferent(String fileName, String newContent) {
			return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
		}

		private Manager(ITextTemplatingEngineHost host, StringBuilder template) {
			this.host = host;
			this.template = template;
		}

		private Block CurrentBlock {
			get { return currentBlock; }
			set {
				if (CurrentBlock != null)
					EndBlock();
				if (value != null)
					value.Start = template.Length;
				currentBlock = value;
			}
		}

		private class VSManager: Manager {
			private EnvDTE.ProjectItem templateProjectItem;
			private EnvDTE.DTE dte;
			private Action<String> checkOutAction;
			private Action<IEnumerable<String>> projectSyncAction;

			public override String DefaultProjectNamespace {
				get {
					return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
				}
			}

			public override String GetCustomToolNamespace(string fileName) {
				return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
			}

			public override void Process(bool split) {
				if (templateProjectItem.ProjectItems == null)
					return;
				base.Process(split);
				projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
			}

			protected override void CreateFile(String fileName, String content) {
				if (IsFileContentDifferent(fileName, content)) {
					CheckoutFileIfRequired(fileName);
					File.WriteAllText(fileName, content);
				}
			}

			internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
				: base(host, template) {
				var hostServiceProvider = (IServiceProvider) host;
				if (hostServiceProvider == null)
					throw new ArgumentNullException("Could not obtain IServiceProvider");
				dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));
				if (dte == null)
					throw new ArgumentNullException("Could not obtain DTE from host");
				templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
				checkOutAction = (String fileName) => dte.SourceControl.CheckOutItem(fileName);
				projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
			}

			private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames) {
				var keepFileNameSet = new HashSet<String>(keepFileNames);
				var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
				var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
				foreach(EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
					projectFiles.Add(projectItem.get_FileNames(0), projectItem);

				// Remove unused items from the project
				foreach(var pair in projectFiles)
					if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
						pair.Value.Delete();

				// Add missing files to the project
				foreach(String fileName in keepFileNameSet)
					if (!projectFiles.ContainsKey(fileName))
						templateProjectItem.ProjectItems.AddFromFile(fileName);
			}

			private void CheckoutFileIfRequired(String fileName) {
				var sc = dte.SourceControl;
				if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
					checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
			}
		}
	}
#>
